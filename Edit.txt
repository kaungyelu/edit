const { Telegraf, Markup } = require('telegraf');
const moment = require('moment-timezone');
const _ = require('lodash');

// Environment variable
const BOT_TOKEN = process.env.BOT_TOKEN;
if (!BOT_TOKEN) {
    console.error("❌ BOT_TOKEN environment variable is not set");
    process.exit(1);
}

// Timezone setup
const MYANMAR_TIMEZONE = 'Asia/Yangon';

// Global data stores
let adminId = null;
const userData = {}; // {username: {date_key: [{num, amt}]}}
const ledger = {};    // {date_key: {number: total_amount}}
const breakLimits = {}; // {date_key: limit}
const pnumberPerDate = {}; // {date_key: power_number}
const dateControl = {}; // {date_key: true/false}
const overbuyList = {}; // {date_key: {username: {num: amount}}}
const messageStore = {}; // {`${user_id}_${message_id}`: {sentMessageId, bets, totalAmount, dateKey}}
const overbuySelections = {}; // {date_key: {username: {num: amount}}}
let currentWorkingDate = null; // For admin date selection

// Com and Za data
const comData = {};
const zaData = {};

const bot = new Telegraf(BOT_TOKEN);

// Utility functions
function reverseNumber(n) {
    const s = n.toString().padStart(2, '0');
    return parseInt(s.split('').reverse().join(''), 10);
}

function getTimeSegment() {
    const now = moment().tz(MYANMAR_TIMEZONE);
    return now.hours() < 12 ? 'AM' : 'PM';
}

function getCurrentDateKey() {
    const now = moment().tz(MYANMAR_TIMEZONE);
    return `${now.format('DD/MM/YYYY')} ${getTimeSegment()}`;
}

function getAvailableDates() {
    const dates = new Set();
    
    // Get dates from user data
    Object.values(userData).forEach(userDataDict => {
        Object.keys(userDataDict).forEach(date => dates.add(date));
    });
    
    // Get dates from ledger
    Object.keys(ledger).forEach(date => dates.add(date));
    
    // Get dates from break limits
    Object.keys(breakLimits).forEach(date => dates.add(date));
    
    // Get dates from pnumber
    Object.keys(pnumberPerDate).forEach(date => dates.add(date));
    
    return Array.from(dates).sort((a, b) => {
        const [dateA, timeA] = a.split(' ');
        const [dateB, timeB] = b.split(' ');
        const momentA = moment(`${dateA} ${timeA === 'AM' ? '00:00' : '12:00'}`, 'DD/MM/YYYY HH:mm');
        const momentB = moment(`${dateB} ${timeB === 'AM' ? '00:00' : '12:00'}`, 'DD/MM/YYYY HH:mm');
        return momentB - momentA;
    });
}

// Menu and command handlers
async function showMenu(ctx) {
    const keyboard = [];
    
    if (ctx.from.id === adminId) {
        keyboard.push(
            ["အရောင်းဖွင့်ရန်", "အရောင်းပိတ်ရန်"],
            ["လည်ချာ", "ဘရိတ်သတ်မှတ်ရန်"],
            ["လျှံဂဏန်းများဝယ်ရန်", "ပေါက်သီးထည့်ရန်"],
            ["ကော်နှင့်အဆ သတ်မှတ်ရန်", "လက်ရှိအချိန်မှစုစုပေါင်း"],
            ["ဂဏန်းနှင့်ငွေပေါင်း", "ကော်မရှင်များ"],
            ["ရက်ချိန်းရန်", "တစ်ယောက်ခြင်းစာရင်း"],
            ["ရက်အလိုက်စာရင်းစုစုပေါင်း"],
            ["ရက်အကုန်ဖျက်ရန်", "ရက်အလိုက်ဖျက်ရန်"]
        );
    } else {
        keyboard.push(["တစ်ယောက်ခြင်းစာရင်း"]);
    }
    
    await ctx.reply("မီနူးကိုရွေးချယ်ပါ", Markup.keyboard(keyboard).resize());
}

async function handleMenuSelection(ctx) {
    const text = ctx.message.text;
    const commandMap = {
        "အရောင်းဖွင့်ရန်": dateOpen,
        "အရောင်းပိတ်ရန်": dateClose,
        "လည်ချာ": ledgerSummary,
        "ဘရိတ်သတ်မှတ်ရန်": breakCommand,
        "လျှံဂဏန်းများဝယ်ရန်": overbuy,
        "ပေါက်သီးထည့်ရန်": pnumber,
        "ကော်နှင့်အဆ သတ်မှတ်ရန်": comandza,
        "လက်ရှိအချိန်မှစုစုပေါင်း": total,
        "ဂဏန်းနှင့်ငွေပေါင်း": tsent,
        "ကော်မရှင်များ": alldata,
        "ရက်အကုန်ဖျက်ရန်": resetData,
        "တစ်ယောက်ခြင်းစာရင်း": posthis,
        "ရက်အလိုက်စာရင်းစုစုပေါင်း": dateall,
        "ရက်ချိန်းရန်": changeWorkingDate,
        "ရက်အလိုက်ဖျက်ရန်": deleteDate
    };
    
    if (commandMap[text]) {
        await commandMap[text](ctx);
    }
}

// Start command
bot.start(async (ctx) => {
    adminId = ctx.from.id;
    currentWorkingDate = getCurrentDateKey();
    console.log(`Admin set to: ${adminId}`);
    await ctx.reply("🤖 Bot started. Admin privileges granted!");
    await showMenu(ctx);
});

// Date open/close commands
async function dateOpen(ctx) {
    if (ctx.from.id !== adminId) {
        await ctx.reply("❌ Admin only command");
        return;
    }
    
    const key = getCurrentDateKey();
    dateControl[key] = true;
    console.log(`Ledger opened for ${key}`);
    await ctx.reply(`✅ ${key} စာရင်းဖွင့်ပြီးပါပြီ`);
}

async function dateClose(ctx) {
    if (ctx.from.id !== adminId) {
        await ctx.reply("❌ Admin only command");
        return;
    }
    
    const key = getCurrentDateKey();
    dateControl[key] = false;
    console.log(`Ledger closed for ${key}`);
    await ctx.reply(`✅ ${key} စာရင်းပိတ်လိုက်ပါပြီ`);
}

// Message handler
bot.on('text', async (ctx) => {
    try {
        const user = ctx.from;
        const text = ctx.message.text;
        
        if (!user || !user.username) {
            await ctx.reply("❌ ကျေးဇူးပြု၍ Telegram username သတ်မှတ်ပါ");
            return;
        }

        const key = currentWorkingDate || getCurrentDateKey();
        if (!dateControl[key]) {
            await ctx.reply("❌ စာရင်းပိတ်ထားပါသည်");
            return;
        }

        if (!text) {
            await ctx.reply("⚠️ မက်ဆေ့ဂျ်မရှိပါ");
            return;
        }

        // Process the message line by line
        const lines = text.split('\n');
        const allBets = [];
        let totalAmount = 0;

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            // Check for wheel cases first
            if (trimmedLine.includes('အခွေ') || trimmedLine.includes('အပူးပါအခွေ')) {
                let basePart, amountPart;
                if (trimmedLine.includes('အခွေ')) {
                    const parts = trimmedLine.split('အခွေ');
                    basePart = parts[0];
                    amountPart = parts[1];
                } else {
                    const parts = trimmedLine.split('အပူးပါအခွေ');
                    basePart = parts[0];
                    amountPart = parts[1];
                }
                
                // Clean base numbers (remove all non-digits)
                const baseNumbers = basePart.replace(/\D/g, '');
                
                // Clean amount (remove all non-digits)
                const amount = parseInt(amountPart.replace(/\D/g, ''), 10);
                
                // Generate all possible pairs
                const pairs = [];
                for (let i = 0; i < baseNumbers.length; i++) {
                    for (let j = 0; j < baseNumbers.length; j++) {
                        if (i !== j) {
                            const num = parseInt(baseNumbers[i] + baseNumbers[j], 10);
                            if (!pairs.includes(num)) {
                                pairs.push(num);
                            }
                        }
                    }
                }
                
                // If အပူးပါအခွေ, add doubles
                if (trimmedLine.includes('အပူးပါအခွေ')) {
                    for (const d of baseNumbers) {
                        const double = parseInt(d + d, 10);
                        if (!pairs.includes(double)) {
                            pairs.push(double);
                        }
                    }
                }
                
                // Add all bets
                for (const num of pairs) {
                    allBets.push(`${num.toString().padStart(2, '0')}-${amount}`);
                    totalAmount += amount;
                }
                continue;
            }

            // Check for special cases
            const specialCases = {
                "အပူး": [0, 11, 22, 33, 44, 55, 66, 77, 88, 99],
                "ပါဝါ": [5, 16, 27, 38, 49, 50, 61, 72, 83, 94],
                "နက္ခ": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နခ": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နက်ခ": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နတ်ခ": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နခက်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နတ်ခက်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နက်ခက်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နတ်ခတ်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နက်ခတ်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နခတ်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "နခပ်": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "ညီကို": [1, 12, 23, 34, 45, 56, 67, 78, 89, 90],
                "ကိုညီ": [9, 10, 21, 32, 43, 54, 65, 76, 87, 98],
            };

            const dynamicTypes = ["ထိပ်", "ပိတ်", "ဘရိတ်", "အပါ"];
            
            // Check for special cases with flexible formatting
            let foundSpecial = false;
            for (const [caseName, caseNumbers] of Object.entries(specialCases)) {
                const caseVariations = [caseName];
                if (caseName === "နက္ခ") {
                    caseVariations.push("နခ", "နက်ခ", "နတ်ခ", "နခက်", "နတ်ခက်", "နက်ခက်", "နတ်ခတ်", "နက်ခတ်", "နခတ်", "နခပ်");
                }
                
                for (const variation of caseVariations) {
                    if (trimmedLine.startsWith(variation)) {
                        const amountStr = trimmedLine.slice(variation.length).trim().replace(/\D/g, '');
                        
                        if (amountStr && parseInt(amountStr, 10) >= 100) {
                            const amt = parseInt(amountStr, 10);
                            for (const num of caseNumbers) {
                                allBets.push(`${num.toString().padStart(2, '0')}-${amt}`);
                                totalAmount += amt;
                            }
                            foundSpecial = true;
                            break;
                        }
                    }
                    if (foundSpecial) break;
                }
                if (foundSpecial) break;
            }
            
            if (foundSpecial) continue;

            // Check for dynamic types with flexible formatting
            for (const dtype of dynamicTypes) {
                if (trimmedLine.includes(dtype)) {
                    const parts = trimmedLine.match(/\d+/g);
                    if (!parts || parts.length < 2) continue;
                    
                    const amount = parseInt(parts[parts.length - 1], 10);
                    if (amount < 100) continue;
                    
                    const digits = parts.slice(0, -1)
                        .filter(p => p.length === 1 && /\d/.test(p))
                        .map(p => parseInt(p, 10));
                    
                    if (digits.length === 0) continue;
                    
                    const numbers = [];
                    if (dtype === "ထိပ်") {
                        for (const d of digits) {
                            for (let j = 0; j < 10; j++) {
                                numbers.push(d * 10 + j);
                            }
                        }
                    } else if (dtype === "ပိတ်") {
                        for (const d of digits) {
                            for (let j = 0; j < 10; j++) {
                                numbers.push(j * 10 + d);
                            }
                        }
                    } else if (dtype === "ဘရိတ်") {
                        for (const d of digits) {
                            for (let n = 0; n < 100; n++) {
                                if ((Math.floor(n / 10) + (n % 10)) % 10 === d) {
                                    numbers.push(n);
                                }
                            }
                        }
                    } else if (dtype === "အပါ") {
                        for (const d of digits) {
                            for (let j = 0; j < 10; j++) {
                                numbers.push(d * 10 + j);
                                numbers.push(j * 10 + d);
                            }
                        }
                    }
                    
                    // Remove duplicates
                    const uniqueNumbers = [...new Set(numbers)];
                    for (const num of uniqueNumbers) {
                        allBets.push(`${num.toString().padStart(2, '0')}-${amount}`);
                        totalAmount += amount;
                    }
                    foundSpecial = true;
                    break;
                }
            }
            
            if (foundSpecial) continue;

            // Process regular number-amount pairs with r/R (flexible formatting)
            if (/r/i.test(trimmedLine)) {
                const rPos = trimmedLine.toLowerCase().indexOf('r');
                const beforeR = trimmedLine.slice(0, rPos);
                const afterR = trimmedLine.slice(rPos + 1);
                
                const numsBefore = beforeR.match(/\d+/g) || [];
                const numsBeforeFiltered = numsBefore
                    .map(n => parseInt(n, 10))
                    .filter(n => n >= 0 && n <= 99);
                
                const amounts = afterR.match(/\d+/g) || [];
                const amountsFiltered = amounts
                    .map(a => parseInt(a, 10))
                    .filter(a => a >= 100);
                
                if (numsBeforeFiltered.length > 0 && amountsFiltered.length > 0) {
                    if (amountsFiltered.length === 1) {
                        // Single amount: apply to both base and reverse
                        for (const num of numsBeforeFiltered) {
                            allBets.push(`${num.toString().padStart(2, '0')}-${amountsFiltered[0]}`);
                            allBets.push(`${reverseNumber(num).toString().padStart(2, '0')}-${amountsFiltered[0]}`);
                            totalAmount += amountsFiltered[0] * 2;
                        }
                    } else {
                        // Two amounts: first for base, second for reverse
                        for (const num of numsBeforeFiltered) {
                            allBets.push(`${num.toString().padStart(2, '0')}-${amountsFiltered[0]}`);
                            allBets.push(`${reverseNumber(num).toString().padStart(2, '0')}-${amountsFiltered[1]}`);
                            totalAmount += amountsFiltered[0] + amountsFiltered[1];
                        }
                    }
                    continue;
                }
            }

            // Process regular number-amount pairs without r/R (flexible formatting)
            const allNumbers = trimmedLine.match(/\d+/g) || [];
            if (allNumbers.length === 0) continue;
            
            let amount = 0;
            const numbers = [];
            
            // Check if last number is amount (>=100)
            const lastNum = parseInt(allNumbers[allNumbers.length - 1], 10);
            if (lastNum >= 100) {
                amount = lastNum;
                // Other numbers are the bet numbers
                for (let i = 0; i < allNumbers.length - 1; i++) {
                    const n = parseInt(allNumbers[i], 10);
                    if (n >= 0 && n <= 99) {
                        numbers.push(n);
                    }
                }
            } else {
                // Maybe the line is just numbers separated by something
                // Try to find pairs where second number is >= 100
                for (let i = 0; i < allNumbers.length - 1; i++) {
                    const num = parseInt(allNumbers[i], 10);
                    const nextNum = parseInt(allNumbers[i + 1], 10);
                    if (num >= 0 && num <= 99 && nextNum >= 100) {
                        numbers.push(num);
                        amount = nextNum;
                        break;
                    }
                }
            }
            
            if (amount >= 100 && numbers.length > 0) {
                for (const num of numbers) {
                    allBets.push(`${num.toString().padStart(2, '0')}-${amount}`);
                    totalAmount += amount;
                }
            }
        }

        if (allBets.length === 0) {
            await ctx.reply("⚠️ အချက်အလက်များကိုစစ်ဆေးပါ\nဥပမာ: 12-1000,12/34-1000 \n 12r1000,12r1000-500");
            return;
        }

        // Update data stores
        if (!userData[user.username]) {
            userData[user.username] = {};
        }
        if (!userData[user.username][key]) {
            userData[user.username][key] = [];
        }

        if (!ledger[key]) {
            ledger[key] = {};
        }

        for (const bet of allBets) {
            const [numStr, amtStr] = bet.split('-');
            const num = parseInt(numStr, 10);
            const amt = parseInt(amtStr, 10);
            
            // Update ledger
            if (!ledger[key][num]) {
                ledger[key][num] = 0;
            }
            ledger[key][num] += amt;
            
            // Update user data
            userData[user.username][key].push({ num, amt });
        }

        // Send confirmation with delete button
        const response = allBets.join('\n') + `\nစုစုပေါင်း ${totalAmount} ကျပ်`;
        const keyboard = Markup.inlineKeyboard([
            Markup.button.callback('🗑 Delete', `delete:${user.id}:${ctx.message.message_id}:${key}`)
        ]);
        
        const sentMessage = await ctx.reply(response, keyboard);
        messageStore[`${user.id}_${ctx.message.message_id}`] = {
            sentMessageId: sentMessage.message_id,
            bets: allBets,
            totalAmount,
            dateKey: key
        };
            
    } catch (e) {
        console.error(`Error in handleMessage: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
});

// Delete bet handlers
bot.action(/^delete:(\d+):(\d+):(.+)$/, async (ctx) => {
    try {
        const [_, userIdStr, messageIdStr, dateKey] = ctx.match;
        const userId = parseInt(userIdStr, 10);
        const messageId = parseInt(messageIdStr, 10);
        
        // Only admin can interact with delete button
        if (ctx.from.id !== adminId) {
            await ctx.editMessageText("❌ Admin only action");
            return;
        }
            
        const keyboard = Markup.inlineKeyboard([
            [Markup.button.callback("✅ OK", `confirm_delete:${userId}:${messageId}:${dateKey}`)],
            [Markup.button.callback("❌ Cancel", `cancel_delete:${userId}:${messageId}:${dateKey}`)]
        ]);
        
        await ctx.editMessageText("⚠️ သေချာလား? ဒီလောင်းကြေးကိုဖျက်မှာလား?", keyboard);
        
    } catch (e) {
        console.error(`Error in deleteBet: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred while processing deletion");
    }
});

bot.action(/^confirm_delete:(\d+):(\d+):(.+)$/, async (ctx) => {
    try {
        const [_, userIdStr, messageIdStr, dateKey] = ctx.match;
        const userId = parseInt(userIdStr, 10);
        const messageId = parseInt(messageIdStr, 10);
        const messageKey = `${userId}_${messageId}`;
        
        if (!messageStore[messageKey]) {
            await ctx.editMessageText("❌ ဒေတာမတွေ့ပါ");
            return;
        }
            
        const { bets, totalAmount } = messageStore[messageKey];
        
        let username = null;
        for (const [uname, data] of Object.entries(userData)) {
            if (data[dateKey]) {
                for (const bet of data[dateKey]) {
                    if (bets.includes(`${bet.num.toString().padStart(2, '0')}-${bet.amt}`)) {
                        username = uname;
                        break;
                    }
                }
                if (username) break;
            }
        }
        
        if (!username) {
            await ctx.editMessageText("❌ User မတွေ့ပါ");
            return;
        }
        
        for (const bet of bets) {
            const [numStr, amtStr] = bet.split('-');
            const num = parseInt(numStr, 10);
            const amt = parseInt(amtStr, 10);
            
            if (ledger[dateKey] && ledger[dateKey][num]) {
                ledger[dateKey][num] -= amt;
                if (ledger[dateKey][num] <= 0) {
                    delete ledger[dateKey][num];
                }
                // Remove date from ledger if empty
                if (Object.keys(ledger[dateKey]).length === 0) {
                    delete ledger[dateKey];
                }
            }
            
            if (userData[username] && userData[username][dateKey]) {
                userData[username][dateKey] = userData[username][dateKey].filter(
                    ({ num: n, amt: a }) => !(n === num && a === amt)
                );
                
                if (userData[username][dateKey].length === 0) {
                    delete userData[username][dateKey];
                    if (Object.keys(userData[username]).length === 0) {
                        delete userData[username];
                    }
                }
            }
        }
        
        delete messageStore[messageKey];
        await ctx.editMessageText("✅ လောင်းကြေးဖျက်ပြီးပါပြီ");
        
    } catch (e) {
        console.error(`Error in confirmDelete: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred while deleting bet");
    }
});

bot.action(/^cancel_delete:(\d+):(\d+):(.+)$/, async (ctx) => {
    try {
        const [_, userIdStr, messageIdStr, dateKey] = ctx.match;
        const userId = parseInt(userIdStr, 10);
        const messageId = parseInt(messageIdStr, 10);
        const messageKey = `${userId}_${messageId}`;
        
        if (messageStore[messageKey]) {
            const { bets, totalAmount } = messageStore[messageKey];
            const response = bets.join('\n') + `\nစုစုပေါင်း ${totalAmount} ကျပ်`;
            const keyboard = Markup.inlineKeyboard([
                Markup.button.callback('🗑 Delete', `delete:${userId}:${messageId}:${dateKey}`)
            ]);
            await ctx.editMessageText(response, keyboard);
        } else {
            await ctx.editMessageText("ℹ️ ဖျက်ခြင်းကိုပယ်ဖျက်လိုက်ပါပြီ");
        }
            
    } catch (e) {
        console.error(`Error in cancelDelete: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred while canceling deletion");
    }
});

// Ledger summary
async function ledgerSummary(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Determine which date to show
        const dateKey = currentWorkingDate || getCurrentDateKey();
        
        if (!ledger[dateKey]) {
            await ctx.reply(`ℹ️ ${dateKey} အတွက် လက်ရှိတွင် လောင်းကြေးမရှိပါ`);
            return;
        }
            
        const lines = [`📒 ${dateKey} လက်ကျန်ငွေစာရင်း`];
        const ledgerData = ledger[dateKey];
        
        let totalAllNumbers = 0; // စုစုပေါင်းငွေအတွက်
        
        for (let i = 0; i < 100; i++) {
            const total = ledgerData[i] || 0;
            if (total > 0) {
                if (pnumberPerDate[dateKey] === i) {
                    lines.push(`🔴 ${i.toString().padStart(2, '0')} ➤ ${total} 🔴`);
                } else {
                    lines.push(`${i.toString().padStart(2, '0')} ➤ ${total}`);
                }
                totalAllNumbers += total;
            }
        }

        if (lines.length === 1) {
            await ctx.reply(`ℹ️ ${dateKey} အတွက် လက်ရှိတွင် လောင်းကြေးမရှိပါ`);
        } else {
            if (pnumberPerDate[dateKey] !== undefined) {
                const pnum = pnumberPerDate[dateKey];
                lines.push(`\n🔴 Power Number: ${pnum.toString().padStart(2, '0')} ➤ ${ledgerData[pnum] || 0}`);
            }
            
            // စုစုပေါင်းငွေပြရန် အောက်ခြေတွင် ထည့်ပါ
            lines.push(`\n💰 စုစုပေါင်း: ${totalAllNumbers} ကျပ်`);
            await ctx.reply(lines.join('\n'));
        }
    } catch (e) {
        console.error(`Error in ledger: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Break command
async function breakCommand(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (ctx.message.text.split(' ').length < 2) {
            if (breakLimits[dateKey]) {
                await ctx.reply(`ℹ️ Usage: /break [limit]\nℹ️ လက်ရှိတွင် break limit: ${breakLimits[dateKey]}`);
            } else {
                await ctx.reply(`ℹ️ Usage: /break [limit]\nℹ️ ${dateKey} အတွက် break limit မသတ်မှတ်ရသေးပါ`);
            }
            return;
        }
            
        try {
            const newLimit = parseInt(ctx.message.text.split(' ')[1], 10);
            breakLimits[dateKey] = newLimit;
            await ctx.reply(`✅ ${dateKey} အတွက် Break limit ကို ${newLimit} အဖြစ်သတ်မှတ်ပြီးပါပြီ`);
            
            if (!ledger[dateKey]) {
                await ctx.reply(`ℹ️ ${dateKey} အတွက် လောင်းကြေးမရှိသေးပါ`);
                return;
            }
                
            const ledgerData = ledger[dateKey];
            const msg = [`📌 ${dateKey} အတွက် Limit (${newLimit}) ကျော်ဂဏန်းများ:`];
            let found = false;
            
            for (const [num, amt] of Object.entries(ledgerData)) {
                if (amt > newLimit) {
                    msg.push(`${num.toString().padStart(2, '0')} ➤ ${amt - newLimit}`);
                    found = true;
                }
            }
            
            if (!found) {
                await ctx.reply(`ℹ️ ${dateKey} အတွက် ဘယ်ဂဏန်းမှ limit (${newLimit}) မကျော်ပါ`);
            } else {
                await ctx.reply(msg.join('\n'));
            }
                
        } catch (e) {
            await ctx.reply("⚠️ Limit amount ထည့်ပါ (ဥပမာ: /break 5000)");
        }
            
    } catch (e) {
        console.error(`Error in break: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Overbuy command
async function overbuy(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (ctx.message.text.split(' ').length < 2) {
            await ctx.reply("ℹ️ ကာဒိုင်အမည်ထည့်ပါ");
            return;
        }
            
        if (!breakLimits[dateKey]) {
            await ctx.reply(`⚠️ ${dateKey} အတွက် ကျေးဇူးပြု၍ /break [limit] ဖြင့် limit သတ်မှတ်ပါ`);
            return;
        }
            
        if (!ledger[dateKey]) {
            await ctx.reply(`ℹ️ ${dateKey} အတွက် လောင်းကြေးမရှိသေးပါ`);
            return;
        }
            
        const username = ctx.message.text.split(' ')[1];
        ctx.session = ctx.session || {};
        ctx.session.overbuyUsername = username;
        ctx.session.overbuyDate = dateKey;
        
        const ledgerData = ledger[dateKey];
        const breakLimitVal = breakLimits[dateKey];
        const overNumbers = {};
        
        for (const [num, amt] of Object.entries(ledgerData)) {
            if (amt > breakLimitVal) {
                overNumbers[num] = amt - breakLimitVal;
            }
        }
        
        if (Object.keys(overNumbers).length === 0) {
            await ctx.reply(`ℹ️ ${dateKey} အတွက် ဘယ်ဂဏန်းမှ limit (${breakLimitVal}) မကျော်ပါ`);
            return;
        }
            
        if (!overbuySelections[dateKey]) {
            overbuySelections[dateKey] = {};
        }
        overbuySelections[dateKey][username] = _.cloneDeep(overNumbers);
        
        const msg = [`${username} ထံမှာတင်ရန်များ (Date: ${dateKey}, Limit: ${breakLimitVal}):`];
        const buttons = [];
        
        for (const [num, amt] of Object.entries(overNumbers)) {
            buttons.push([
                Markup.button.callback(
                    `${num.toString().padStart(2, '0')} ➤ ${amt} ${overbuySelections[dateKey][username][num] ? '✅' : '⬜'}`,
                    `overbuy_select:${num}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.reply(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuy: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Overbuy selection handlers
bot.action(/^overbuy_select:(\d+)$/, async (ctx) => {
    try {
        const [_, numStr] = ctx.match;
        const num = parseInt(numStr, 10);
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("❌ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey] || !overbuySelections[dateKey][username]) {
            await ctx.editMessageText("❌ Error: Selection data not found");
            return;
        }
            
        if (overbuySelections[dateKey][username][num]) {
            delete overbuySelections[dateKey][username][num];
        } else {
            const breakLimitVal = breakLimits[dateKey];
            overbuySelections[dateKey][username][num] = ledger[dateKey][num] - breakLimitVal;
        }
            
        const msg = [`${username} ထံမှာတင်ရန်များ (Date: ${dateKey}):`];
        const buttons = [];
        
        for (const [n, amt] of Object.entries(overbuySelections[dateKey][username])) {
            buttons.push([
                Markup.button.callback(
                    `${n.toString().padStart(2, '0')} ➤ ${amt} ${overbuySelections[dateKey][username][n] ? '✅' : '⬜'}`,
                    `overbuy_select:${n}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuySelect: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("overbuy_select_all", async (ctx) => {
    try {
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("❌ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey]) {
            overbuySelections[dateKey] = {};
        }
            
        const breakLimitVal = breakLimits[dateKey];
        const ledgerData = ledger[dateKey];
        overbuySelections[dateKey][username] = {};
        
        for (const [num, amt] of Object.entries(ledgerData)) {
            if (amt > breakLimitVal) {
                overbuySelections[dateKey][username][num] = amt - breakLimitVal;
            }
        }
        
        const msg = [`${username} ထံမှာတင်ရန်များ (Date: ${dateKey}):`];
        const buttons = [];
        
        for (const [num, amt] of Object.entries(overbuySelections[dateKey][username])) {
            buttons.push([
                Markup.button.callback(
                    `${num.toString().padStart(2, '0')} ➤ ${amt} ✅`,
                    `overbuy_select:${num}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuySelectAll: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("overbuy_unselect_all", async (ctx) => {
    try {
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("❌ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey]) {
            overbuySelections[dateKey] = {};
        }
            
        overbuySelections[dateKey][username] = {};
        
        const breakLimitVal = breakLimits[dateKey];
        const ledgerData = ledger[dateKey];
        const overNumbers = {};
        
        for (const [num, amt] of Object.entries(ledgerData)) {
            if (amt > breakLimitVal) {
                overNumbers[num] = amt - breakLimitVal;
            }
        }
        
        const msg = [`${username} ထံမှာတင်ရန်များ (Date: ${dateKey}):`];
        const buttons = [];
        
        for (const [num, amt] of Object.entries(overNumbers)) {
            buttons.push([
                Markup.button.callback(
                    `${num.toString().padStart(2, '0')} ➤ ${amt} ⬜`,
                    `overbuy_select:${num}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuyUnselectAll: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("overbuy_confirm", async (ctx) => {
    try {
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("❌ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey] || !overbuySelections[dateKey][username]) {
            await ctx.editMessageText("❌ Error: Selection data not found");
            return;
        }
            
        const selectedNumbers = overbuySelections[dateKey][username];
        if (Object.keys(selectedNumbers).length === 0) {
            await ctx.editMessageText("⚠️ ဘာဂဏန်းမှမရွေးထားပါ");
            return;
        }
            
        if (!userData[username]) {
            userData[username] = {};
        }
        if (!userData[username][dateKey]) {
            userData[username][dateKey] = [];
        }
            
        let totalAmount = 0;
        const bets = [];
        for (const [numStr, amt] of Object.entries(selectedNumbers)) {
            const num = parseInt(numStr, 10);
            userData[username][dateKey].push({ num, amt: -amt });
            bets.push(`${num.toString().padStart(2, '0')}-${amt}`);
            totalAmount += amt;
            
            // Update ledger
            ledger[dateKey][num] = (ledger[dateKey][num] || 0) - amt;
            if (ledger[dateKey][num] <= 0) {
                delete ledger[dateKey][num];
            }
        }
        
        // Initialize overbuy_list for date if needed
        if (!overbuyList[dateKey]) {
            overbuyList[dateKey] = {};
        }
        overbuyList[dateKey][username] = _.cloneDeep(selectedNumbers);
        
        const response = `${username} - ${dateKey}\n` + bets.join('\n') + `\nစုစုပေါင်း ${totalAmount} ကျပ်`;
        await ctx.editMessageText(response);
        
    } catch (e) {
        console.error(`Error in overbuyConfirm: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

// Pnumber command
async function pnumber(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (ctx.message.text.split(' ').length < 2) {
            if (pnumberPerDate[dateKey] !== undefined) {
                await ctx.reply(`ℹ️ Usage: /pnumber [number]\nℹ️ ${dateKey} အတွက် Power Number: ${pnumberPerDate[dateKey].toString().padStart(2, '0')}`);
            } else {
                await ctx.reply(`ℹ️ Usage: /pnumber [number]\nℹ️ ${dateKey} အတွက် Power Number မသတ်မှတ်ရသေးပါ`);
            }
            return;
        }
            
        try {
            const num = parseInt(ctx.message.text.split(' ')[1], 10);
            if (num < 0 || num > 99) {
                await ctx.reply("⚠️ ဂဏန်းကို 0 နှင့် 99 ကြားထည့်ပါ");
                return;
            }
                
            pnumberPerDate[dateKey] = num;
            await ctx.reply(`✅ ${dateKey} အတွက် Power Number ကို ${num.toString().padStart(2, '0')} အဖြစ်သတ်မှတ်ပြီး`);
            
            // Show report for this date
            const msg = [];
            let totalPower = 0;
            
            for (const [user, records] of Object.entries(userData)) {
                if (records[dateKey]) {
                    let userTotal = 0;
                    for (const { num: betNum, amt } of records[dateKey]) {
                        if (betNum === num) {
                            userTotal += amt;
                        }
                    }
                    if (userTotal > 0) {
                        msg.push(`${user}: ${num.toString().padStart(2, '0')} ➤ ${userTotal}`);
                        totalPower += userTotal;
                    }
                }
            }
            
            if (msg.length > 0) {
                msg.push(`\n🔴 ${dateKey} အတွက် Power Number စုစုပေါင်း: ${totalPower}`);
                await ctx.reply(msg.join('\n'));
            } else {
                await ctx.reply(`ℹ️ ${dateKey} အတွက် ${num.toString().padStart(2, '0')} အတွက် လောင်းကြေးမရှိပါ`);
            }
                
        } catch (e) {
            await ctx.reply("⚠️ ဂဏန်းမှန်မှန်ထည့်ပါ (ဥပမာ: /pnumber 15)");
        }
            
    } catch (e) {
        console.error(`Error in pnumber: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Comandza command
async function comandza(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("ℹ️ လက်ရှိ user မရှိပါ");
            return;
        }
            
        const users = Object.keys(userData);
        const buttons = users.map(u => [Markup.button.callback(u, `comza:${u}`)]);
        await ctx.reply("👉 User ကိုရွေးပါ", Markup.inlineKeyboard(buttons));
    } catch (e) {
        console.error(`Error in comandza: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

bot.action(/^comza:(.+)$/, async (ctx) => {
    try {
        const username = ctx.match[1];
        ctx.session = ctx.session || {};
        ctx.session.selectedUser = username;
        await ctx.editMessageText(`👉 ${username} ကိုရွေးထားသည်။ 15/80 လို့ထည့်ပါ`);
    } catch (e) {
        console.error(`Error in comzaInput: ${e.message}`);
        await ctx.editMessageText(`❌ Error: ${e.message}`);
    }
});

// Comza text handler
bot.on('text', async (ctx) => {
    try {
        if (!ctx.session?.selectedUser) return;
        
        const user = ctx.session.selectedUser;
        const text = ctx.message.text;
        
        if (text && text.includes('/')) {
            try {
                const parts = text.split('/');
                if (parts.length !== 2) throw new Error();
                
                const com = parseInt(parts[0], 10);
                const za = parseInt(parts[1], 10);
                
                if (com < 0 || com > 100 || za < 0) throw new Error();
                    
                comData[user] = com;
                zaData[user] = za;
                delete ctx.session.selectedUser;
                await ctx.reply(`✅ Com ${com}%, Za ${za} မှတ်ထားပြီး`);
            } catch (e) {
                await ctx.reply("⚠️ မှန်မှန်ရေးပါ (ဥပမာ: 15/80)");
            }
        }
    } catch (e) {
        console.error(`Error in comzaText: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
});

// Total command
async function total(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (pnumberPerDate[dateKey] === undefined) {
            await ctx.reply(`⚠️ ${dateKey} အတွက် ကျေးဇူးပြု၍ /pnumber [number] ဖြင့် Power Number သတ်မှတ်ပါ`);
            return;
        }
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("ℹ️ လက်ရှိစာရင်းမရှိပါ");
            return;
        }
            
        const pnum = pnumberPerDate[dateKey];
        const msg = [`📊 ${dateKey} အတွက် စုပေါင်းရလဒ်`];
        let totalNet = 0;
        
        for (const [user, records] of Object.entries(userData)) {
            if (records[dateKey]) {
                let userTotalAmt = 0;
                let userPamt = 0;
                
                for (const { num, amt } of records[dateKey]) {
                    userTotalAmt += amt;
                    if (num === pnum) {
                        userPamt += amt;
                    }
                }
                
                const com = comData[user] || 0;
                const za = zaData[user] || 80;
                
                const commissionAmt = Math.floor((userTotalAmt * com) / 100);
                const afterCom = userTotalAmt - commissionAmt;
                const winAmt = userPamt * za;
                
                const net = afterCom - winAmt;
                const status = net < 0 ? "ဒိုင်ကပေးရမည်" : "ဒိုင်ကရမည်";
                
                const userReport = [
                    `👤 ${user}`,
                    `💵 စုစုပေါင်း: ${userTotalAmt}`,
                    `📊 Com(${com}%) ➤ ${commissionAmt}`,
                    `💰 Com ပြီး: ${afterCom}`,
                    `🔢 Power Number(${pnum.toString().padStart(2, '0')}) ➤ ${userPamt}`,
                    `🎯 Za(${za}) ➤ ${winAmt}`,
                    `📈 ရလဒ်: ${Math.abs(net)} (${status})`,
                    "-----------------"
                ].join('\n');
                
                msg.push(userReport);
                totalNet += net;
            }
        }

        if (msg.length > 1) {
            msg.push(`\n📊 စုစုပေါင်းရလဒ်: ${Math.abs(totalNet)} (${totalNet < 0 ? 'ဒိုင်အရှုံး' : 'ဒိုင်အမြတ်'})`);
            await ctx.reply(msg.join('\n'));
        } else {
            await ctx.reply(`ℹ️ ${dateKey} အတွက် ဒေတာမရှိပါ`);
        }
    } catch (e) {
        console.error(`Error in total: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Tsent command
async function tsent(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("ℹ️ လက်ရှိ user မရှိပါ");
            return;
        }
            
        for (const user in userData) {
            if (userData[user][dateKey]) {
                const userReport = [`👤 ${user} - ${dateKey}:`];
                let totalAmt = 0;
                
                for (const { num, amt } of userData[user][dateKey]) {
                    userReport.push(`  - ${num.toString().padStart(2, '0')} ➤ ${amt}`);
                    totalAmt += amt;
                }
                
                userReport.push(`💵 စုစုပေါင်း: ${totalAmt}`);
                await ctx.reply(userReport.join('\n'));
            }
        }
        
        await ctx.reply(`✅ ${dateKey} အတွက် စာရင်းများအားလုံး ပေးပို့ပြီးပါပြီ`);
    } catch (e) {
        console.error(`Error in tsent: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Alldata command
async function alldata(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("ℹ️ လက်ရှိစာရင်းမရှိပါ");
            return;
        }
            
        const msg = ["👥 မှတ်ပုံတင်ထားသော user များ:"];
        msg.push(...Object.keys(userData).map(u => `• ${u}`));
        
        await ctx.reply(msg.join('\n'));
    } catch (e) {
        console.error(`Error in alldata: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Reset data command
async function resetData(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Clear all data
        Object.keys(userData).forEach(key => delete userData[key]);
        Object.keys(ledger).forEach(key => delete ledger[key]);
        Object.keys(zaData).forEach(key => delete zaData[key]);
        Object.keys(comData).forEach(key => delete comData[key]);
        Object.keys(dateControl).forEach(key => delete dateControl[key]);
        Object.keys(overbuyList).forEach(key => delete overbuyList[key]);
        Object.keys(overbuySelections).forEach(key => delete overbuySelections[key]);
        Object.keys(breakLimits).forEach(key => delete breakLimits[key]);
        Object.keys(pnumberPerDate).forEach(key => delete pnumberPerDate[key]);
        
        currentWorkingDate = getCurrentDateKey();
        
        await ctx.reply("✅ ဒေတာများအားလုံးကို ပြန်လည်သုတ်သင်ပြီး လက်ရှိနေ့သို့ပြန်လည်သတ်မှတ်ပြီးပါပြီ");
    } catch (e) {
        console.error(`Error in resetData: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Posthis command
async function posthis(ctx) {
    try {
        const isAdmin = ctx.from.id === adminId;
        let username;
        
        if (isAdmin && ctx.message.text.split(' ').length < 2) {
            if (Object.keys(userData).length === 0) {
                await ctx.reply("ℹ️ လက်ရှိ user မရှိပါ");
                return;
            }
                
            const buttons = Object.keys(userData).map(u => [Markup.button.callback(u, `posthis:${u}`)]);
            await ctx.reply(
                "ဘယ် user ရဲ့စာရင်းကိုကြည့်မလဲ?",
                Markup.inlineKeyboard(buttons)
            );
            return;
        }
        
        username = isAdmin ? ctx.message.text.split(' ')[1] : ctx.from.username;
        
        if (!username) {
            await ctx.reply("❌ User မရှိပါ");
            return;
        }
            
        if (!userData[username]) {
            await ctx.reply(`ℹ️ ${username} အတွက် စာရင်းမရှိပါ`);
            return;
        }
            
        // For non-admin, show current date only
        const dateKey = isAdmin ? null : getCurrentDateKey();
        
        const msg = [`📊 ${username} ရဲ့လောင်းကြေးမှတ်တမ်း`];
        let totalAmount = 0;
        let pnumberTotal = 0;
        
        if (isAdmin) {
            // Admin can see all dates
            for (const [dateKey, records] of Object.entries(userData[username])) {
                const pnum = pnumberPerDate[dateKey];
                const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
                
                msg.push(`\n📅 ${dateKey}${pnumStr}:`);
                for (const { num, amt } of records) {
                    if (pnum !== undefined && num === pnum) {
                        msg.push(`🔴 ${num.toString().padStart(2, '0')} ➤ ${amt} 🔴`);
                        pnumberTotal += amt;
                    } else {
                        msg.push(`${num.toString().padStart(2, '0')} ➤ ${amt}`);
                    }
                    totalAmount += amt;
                }
            }
        } else {
            // Non-admin only sees current date
            if (userData[username][dateKey]) {
                const pnum = pnumberPerDate[dateKey];
                const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
                
                msg.push(`\n📅 ${dateKey}${pnumStr}:`);
                for (const { num, amt } of userData[username][dateKey]) {
                    if (pnum !== undefined && num === pnum) {
                        msg.push(`🔴 ${num.toString().padStart(2, '0')} ➤ ${amt} 🔴`);
                        pnumberTotal += amt;
                    } else {
                        msg.push(`${num.toString().padStart(2, '0')} ➤ ${amt}`);
                    }
                    totalAmount += amt;
                }
            }
        }
        
        if (msg.length > 1) {
            msg.push(`\n💵 စုစုပေါင်း: ${totalAmount}`);
            if (pnumberTotal > 0) {
                msg.push(`🔴 Power Number စုစုပေါင်း: ${pnumberTotal}`);
            }
            await ctx.reply(msg.join('\n'));
        } else {
            await ctx.reply(`ℹ️ ${username} အတွက် စာရင်းမရှိပါ`);
        }
        
    } catch (e) {
        console.error(`Error in posthis: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

bot.action(/^posthis:(.+)$/, async (ctx) => {
    try {
        const username = ctx.match[1];
        const msg = [`📊 ${username} ရဲ့လောင်းကြေးမှတ်တမ်း`];
        let totalAmount = 0;
        let pnumberTotal = 0;
        
        if (userData[username]) {
            for (const [dateKey, records] of Object.entries(userData[username])) {
                const pnum = pnumberPerDate[dateKey];
                const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
                
                msg.push(`\n📅 ${dateKey}${pnumStr}:`);
                for (const { num, amt } of records) {
                    if (pnum !== undefined && num === pnum) {
                        msg.push(`🔴 ${num.toString().padStart(2, '0')} ➤ ${amt} 🔴`);
                        pnumberTotal += amt;
                    } else {
                        msg.push(`${num.toString().padStart(2, '0')} ➤ ${amt}`);
                    }
                    totalAmount += amt;
                }
            }
            
            if (msg.length > 1) {
                msg.push(`\n💵 စုစုပေါင်း: ${totalAmount}`);
                if (pnumberTotal > 0) {
                    msg.push(`🔴 Power Number စုစုပေါင်း: ${pnumberTotal}`);
                }
                await ctx.editMessageText(msg.join('\n'));
            } else {
                await ctx.editMessageText(`ℹ️ ${username} အတွက် စာရင်းမရှိပါ`);
            }
        } else {
            await ctx.editMessageText(`ℹ️ ${username} အတွက် စာရင်းမရှိပါ`);
        }
            
    } catch (e) {
        console.error(`Error in posthisCallback: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

// Dateall command
async function dateall(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Get all unique dates from user_data
        const allDates = getAvailableDates();
        
        if (allDates.length === 0) {
            await ctx.reply("ℹ️ မည်သည့်စာရင်းမှ မရှိသေးပါ");
            return;
        }
            
        // Initialize selection dictionary
        const dateallSelections = {};
        allDates.forEach(date => dateallSelections[date] = false);
        ctx.session = ctx.session || {};
        ctx.session.dateallSelections = dateallSelections;
        
        // Build message with checkboxes
        const msg = ["📅 စာရင်းရှိသည့်နေ့ရက်များကို ရွေးချယ်ပါ:"];
        const buttons = [];
        
        for (const date of allDates) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = dateallSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? '✅' : '⬜'}`,
                    `dateall_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("👁‍🗨 View", "dateall_view")]);
        
        await ctx.reply(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in dateall: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

bot.action(/^dateall_toggle:(.+)$/, async (ctx) => {
    try {
        const dateKey = ctx.match[1];
        const dateallSelections = ctx.session?.dateallSelections || {};
        
        if (!dateallSelections[dateKey]) {
            await ctx.editMessageText("❌ Error: Date not found");
            return;
        }
            
        // Toggle selection status
        dateallSelections[dateKey] = !dateallSelections[dateKey];
        ctx.session.dateallSelections = dateallSelections;
        
        // Rebuild the message with updated selections
        const msg = ["📅 စာရင်းရှိသည့်နေ့ရက်များကို ရွေးချယ်ပါ:"];
        const buttons = [];
        
        for (const date in dateallSelections) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = dateallSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? '✅' : '⬜'}`,
                    `dateall_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("👁‍🗨 View", "dateall_view")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in dateallToggle: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("dateall_view", async (ctx) => {
    try {
        // 1. Get selected dates
        const dateallSelections = ctx.session?.dateallSelections || {};
        const selectedDates = Object.entries(dateallSelections)
            .filter(([_, selected]) => selected)
            .map(([date]) => date);
        
        if (selectedDates.length === 0) {
            await ctx.editMessageText("⚠️ မည်သည့်နေ့ရက်ကိုမှ မရွေးချယ်ထားပါ");
            return;
        }

        // 2. Initialize data storage
        const userReports = {};  // {username: {totalBet: 0, powerBet: 0, com: X, za: Y}}
        const grandTotals = {
            totalBet: 0,
            powerBet: 0,
            commission: 0,
            winAmount: 0,
            netResult: 0
        };

        // 3. Process bets WITHOUT overbuy adjustment
        for (const [username, userDates] of Object.entries(userData)) {
            if (!userReports[username]) {
                userReports[username] = {
                    totalBet: 0,
                    powerBet: 0,
                    com: comData[username] || 0,
                    za: zaData[username] || 80
                };
            }
            
            for (const dateKey of selectedDates) {
                if (userDates[dateKey]) {
                    // Track total bets
                    const dateTotal = userDates[dateKey].reduce((sum, { amt }) => sum + amt, 0);
                    userReports[username].totalBet += dateTotal;
                    
                    // Track power number bets
                    const pnum = pnumberPerDate[dateKey];
                    if (pnum !== undefined) {
                        const powerAmt = userDates[dateKey]
                            .filter(({ num }) => num === pnum)
                            .reduce((sum, { amt }) => sum + amt, 0);
                        userReports[username].powerBet += powerAmt;
                    }
                }
            }
        }

        // 4. Calculate financials
        const messages = ["📊 ရွေးချယ်ထားသော နေ့ရက်များ စုစုပေါင်းရလဒ် (Overbuy မပါ)"];
        messages.push(`📅 ရက်စွဲများ: ${selectedDates.join(', ')}\n`);
        
        for (const [username, report] of Object.entries(userReports)) {
            // Calculate values
            const commission = Math.floor((report.totalBet * report.com) / 100);
            const afterCom = report.totalBet - commission;
            const winAmount = report.powerBet * report.za;
            const netResult = afterCom - winAmount;
            
            // Build user message
            const userMsg = [
                `👤 ${username}`,
                `💵 စုစုပေါင်းလောင်းကြေး: ${report.totalBet}`,
                `📊 Com (${report.com}%): ${commission}`,
                `💰 Com ပြီး: ${afterCom}`
            ];
            
            if (report.powerBet > 0) {
                userMsg.push(
                    `🔴 Power Number: ${report.powerBet}`,
                    `🎯 Za (${report.za}): ${winAmount}`
                );
            }
            
            userMsg.push(
                `📈 ရလဒ်: ${Math.abs(netResult)} (${netResult < 0 ? 'ဒိုင်ကပေးရန်' : 'ဒိုင်ကရမည်'})`
            );
            
            messages.push(userMsg.join('\n'));
            messages.push("⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯");
            
            // Update grand totals
            grandTotals.totalBet += report.totalBet;
            grandTotals.powerBet += report.powerBet;
            grandTotals.commission += commission;
            grandTotals.winAmount += winAmount;
            grandTotals.netResult += netResult;
        }

        // 5. Add grand totals
        messages.push("\n📌 စုစုပေါင်းရလဒ်:");
        messages.push(`💵 စုစုပေါင်းလောင်းကြေး: ${grandTotals.totalBet}`);
        messages.push(`📊 Com စုစုပေါင်း: ${grandTotals.commission}`);
        
        if (grandTotals.powerBet > 0) {
            messages.push(`🔴 Power Number စုစုပေါင်း: ${grandTotals.powerBet}`);
            messages.push(`🎯 Win Amount စုစုပေါင်း: ${grandTotals.winAmount}`);
        }
        
        messages.push(
            `📊 စုစုပေါင်းရလဒ်: ${Math.abs(grandTotals.netResult)} ` +
            `(${grandTotals.netResult < 0 ? 'ဒိုင်အရှုံး' : 'ဒိုင်အမြတ်'})`
        );

        // 6. Send message (split if too long)
        const fullMessage = messages.join('\n');
        if (fullMessage.length > 4000) {
            const half = Math.floor(messages.length / 2);
            await ctx.editMessageText(messages.slice(0, half).join('\n'));
            await ctx.telegram.sendMessage(
                ctx.chat.id,
                messages.slice(half).join('\n')
            );
        } else {
            await ctx.editMessageText(fullMessage);
        }

    } catch (e) {
        console.error(`Error in dateallView: ${e.message}`);
        await ctx.editMessageText("❌ တွက်ချက်မှုအမှားဖြစ်နေပါသည်");
    }
});

// Change working date command
async function changeWorkingDate(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
        
        // Show calendar with AM/PM selection
        const keyboard = [
            [Markup.button.callback("🗓 လက်ရှိလအတွက် ပြက္ခဒိန်", "cdate_calendar")],
            [Markup.button.callback("⏰ AM ရွေးရန်", "cdate_am")],
            [Markup.button.callback("🌙 PM ရွေးရန်", "cdate_pm")],
            [Markup.button.callback("📆 ယနေ့ဖွင့်ရန်", "cdate_open")]
        ];
        
        await ctx.reply(
            "👉 လက်ရှိ အလုပ်လုပ်ရမည့်နေ့ရက်ကို ရွေးချယ်ပါ\n" +
            "• ပြက္ခဒိန်ဖြင့်ရွေးရန်: 🗓 ခလုတ်ကိုနှိပ်ပါ\n" +
            "• AM သို့ပြောင်းရန်: ⏰ ခလုတ်ကိုနှိပ်ပါ\n" +
            "• PM သို့ပြောင်းရန်: 🌙 ခလုတ်ကိုနှိပ်ပါ\n" +
            "• ယနေ့သို့ပြန်ရန်: 📆 ခလုတ်ကိုနှိပ်ပါ",
            Markup.inlineKeyboard(keyboard)
        );
    } catch (e) {
        console.error(`Error in changeWorkingDate: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

// Calendar handlers
bot.action("cdate_calendar", async (ctx) => {
    try {
        const now = moment().tz(MYANMAR_TIMEZONE);
        const year = now.year();
        const month = now.month() + 1; // moment months are 0-11
        
        // Create calendar header
        const monthNames = [
            "ဇန်နဝါရီ", "ဖေဖော်ဝါရီ", "မတ်", "ဧပြီ", "မေ", "ဇွန်",
            "ဇူလိုင်", "ဩဂုတ်", "စက်တင်ဘာ", "အောက်တိုဘာ", "နိုဝင်ဘာ", "ဒီဇင်ဘာ"
        ];
        const calHeader = `${monthNames[month - 1]} ${year}`;
        const days = ["တနင်္လာ", "အင်္ဂါ", "ဗုဒ္ဓဟူး", "ကြာသပတေး", "သောကြာ", "စနေ", "တနင်္ဂနွေ"];
        
        // Generate calendar days
        const firstDay = moment(`${year}-${month}-01`, 'YYYY-MM-DD').tz(MYANMAR_TIMEZONE);
        const daysInMonth = firstDay.daysInMonth();
        const firstDayOfWeek = firstDay.day(); // 0-6 (Sunday-Saturday)
        
        // Adjust for Myanmar week start (Monday)
        const myanmarFirstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
        
        const weeks = [];
        let week = [];
        
        // Add empty cells for days before the first day of the month
        for (let i = 0; i < myanmarFirstDayOfWeek; i++) {
            week.push(Markup.button.callback(" ", "ignore"));
        }
        
        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
            week.push(Markup.button.callback(day.toString(), `cdate_day:${dateStr}`));
            
            if (week.length === 7) {
                weeks.push(week);
                week = [];
            }
        }
        
        // Add remaining days of the last week
        if (week.length > 0) {
            while (week.length < 7) {
                week.push(Markup.button.callback(" ", "ignore"));
            }
            weeks.push(week);
        }
        
        // Build calendar keyboard
        const keyboard = [];
        keyboard.push([Markup.button.callback(calHeader, "ignore")]);
        keyboard.push(days.map(day => Markup.button.callback(day, "ignore")));
        keyboard.push(...weeks);
        
        // Add navigation and back buttons
        keyboard.push([
            Markup.button.callback("⬅️ ယခင်", "cdate_prev_month"),
            Markup.button.callback("➡️ နောက်", "cdate_next_month")
        ]);
        keyboard.push([Markup.button.callback("🔙 နောက်သို့", "cdate_back")]);
        
        await ctx.editMessageText("🗓 နေ့ရက်ရွေးရန် ပြက္ခဒိန်", Markup.inlineKeyboard(keyboard));
        
    } catch (e) {
        console.error(`Error in showCalendar: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action(/^cdate_day:(.+)$/, async (ctx) => {
    try {
        const dateStr = ctx.match[1];
        ctx.session = ctx.session || {};
        ctx.session.selectedDate = dateStr;
        
        // Ask for AM/PM selection
        const keyboard = [
            [Markup.button.callback("⏰ AM", "cdate_set_am")],
            [Markup.button.callback("🌙 PM", "cdate_set_pm")],
            [Markup.button.callback("🔙 နောက်သို့", "cdate_back")]
        ];
        
        await ctx.editMessageText(
            `👉 ${dateStr} အတွက် အချိန်ပိုင်းရွေးပါ`,
            Markup.inlineKeyboard(keyboard)
        );
        
    } catch (e) {
        console.error(`Error in handleDaySelection: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action(/^cdate_set_(am|pm)$/, async (ctx) => {
    try {
        const timeSegment = ctx.match[1].toUpperCase();
        const dateStr = ctx.session?.selectedDate;
        
        if (!dateStr) {
            await ctx.editMessageText("❌ Error: Date not selected");
            return;
        }
            
        currentWorkingDate = `${dateStr} ${timeSegment}`;
        await ctx.editMessageText(`✅ လက်ရှိ အလုပ်လုပ်ရမည့်နေ့ရက်ကို ${currentWorkingDate} အဖြစ်ပြောင်းလိုက်ပါပြီ`);
        
    } catch (e) {
        console.error(`Error in setAmPm: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("cdate_am", async (ctx) => {
    try {
        if (currentWorkingDate) {
            const datePart = currentWorkingDate.split(' ')[0];
            currentWorkingDate = `${datePart} AM`;
            await ctx.editMessageText(`✅ လက်ရှိ အလုပ်လုပ်ရမည့်နေ့ရက်ကို ${currentWorkingDate} အဖြစ်ပြောင်းလိုက်ပါပြီ`);
        } else {
            await ctx.editMessageText("❌ လက်ရှိနေ့ရက် သတ်မှတ်ထားခြင်းမရှိပါ");
        }
    } catch (e) {
        console.error(`Error in setAm: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("cdate_pm", async (ctx) => {
    try {
        if (currentWorkingDate) {
            const datePart = currentWorkingDate.split(' ')[0];
            currentWorkingDate = `${datePart} PM`;
            await ctx.editMessageText(`✅ လက်ရှိ အလုပ်လုပ်ရမည့်နေ့ရက်ကို ${currentWorkingDate} အဖြစ်ပြောင်းလိုက်ပါပြီ`);
        } else {
            await ctx.editMessageText("❌ လက်ရှိနေ့ရက် သတ်မှတ်ထားခြင်းမရှိပါ");
        }
    } catch (e) {
        console.error(`Error in setPm: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("cdate_open", async (ctx) => {
    try {
        currentWorkingDate = getCurrentDateKey();
        await ctx.editMessageText(`✅ လက်ရှိ အလုပ်လုပ်ရမည့်နေ့ရက်ကို ${currentWorkingDate} အဖြစ်ပြောင်းလိုက်ပါပြီ`);
    } catch (e) {
        console.error(`Error in openCurrentDate: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action(/^cdate_(prev|next)_month$/, async (ctx) => {
    try {
        const direction = ctx.match[1];
        await ctx.answerCbQuery("ℹ️ လများလှန်ကြည့်ခြင်းအား နောက်ထပ်ဗားရှင်းတွင် ထည့်သွင်းပါမည်");
    } catch (e) {
        console.error(`Error in navigateMonth: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("cdate_back", async (ctx) => {
    try {
        await changeWorkingDate(ctx);
    } catch (e) {
        console.error(`Error in backToMain: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

// Delete date command
async function deleteDate(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("❌ Admin only command");
            return;
        }
            
        // Get all available dates
        const availableDates = getAvailableDates();
        
        if (availableDates.length === 0) {
            await ctx.reply("ℹ️ မည်သည့်စာရင်းမှ မရှိသေးပါ");
            return;
        }
            
        // Initialize selection dictionary
        const datedeleteSelections = {};
        availableDates.forEach(date => datedeleteSelections[date] = false);
        ctx.session = ctx.session || {};
        ctx.session.datedeleteSelections = datedeleteSelections;
        
        // Build message with checkboxes
        const msg = ["🗑 ဖျက်လိုသောနေ့ရက်များကို ရွေးချယ်ပါ:"];
        const buttons = [];
        
        for (const date of availableDates) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = datedeleteSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? '✅' : '⬜'}`,
                    `datedelete_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("✅ Delete Selected", "datedelete_confirm")]);
        
        await ctx.reply(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in deleteDate: ${e.message}`);
        await ctx.reply(`❌ Error: ${e.message}`);
    }
}

bot.action(/^datedelete_toggle:(.+)$/, async (ctx) => {
    try {
        const dateKey = ctx.match[1];
        const datedeleteSelections = ctx.session?.datedeleteSelections || {};
        
        if (!datedeleteSelections[dateKey]) {
            await ctx.editMessageText("❌ Error: Date not found");
            return;
        }
            
        // Toggle selection status
        datedeleteSelections[dateKey] = !datedeleteSelections[dateKey];
        ctx.session.datedeleteSelections = datedeleteSelections;
        
        // Rebuild the message with updated selections
        const msg = ["🗑 ဖျက်လိုသောနေ့ရက်များကို ရွေးချယ်ပါ:"];
        const buttons = [];
        
        for (const date in datedeleteSelections) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = datedeleteSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? '✅' : '⬜'}`,
                    `datedelete_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("✅ Delete Selected", "datedelete_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in datedeleteToggle: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

bot.action("datedelete_confirm", async (ctx) => {
    try {
        const datedeleteSelections = ctx.session?.datedeleteSelections || {};
        
        // Get selected dates
        const selectedDates = Object.entries(datedeleteSelections)
            .filter(([_, selected]) => selected)
            .map(([date]) => date);
        
        if (selectedDates.length === 0) {
            await ctx.editMessageText("⚠️ မည်သည့်နေ့ရက်ကိုမှ မရွေးချယ်ထားပါ");
            return;
        }
            
        // Delete data for selected dates
        for (const dateKey of selectedDates) {
            // Remove from user_data
            for (const user in userData) {
                if (userData[user][dateKey]) {
                    delete userData[user][dateKey];
                }
                // Remove user if no dates left
                if (Object.keys(userData[user]).length === 0) {
                    delete userData[user];
                }
            }
            
            // Remove from ledger
            if (ledger[dateKey]) {
                delete ledger[dateKey];
            }
            
            // Remove from break_limits
            if (breakLimits[dateKey]) {
                delete breakLimits[dateKey];
            }
            
            // Remove from pnumber_per_date
            if (pnumberPerDate[dateKey]) {
                delete pnumberPerDate[dateKey];
            }
            
            // Remove from date_control
            if (dateControl[dateKey]) {
                delete dateControl[dateKey];
            }
            
            // Remove from overbuy_list
            if (overbuyList[dateKey]) {
                delete overbuyList[dateKey];
            }
            
            // Remove from overbuy_selections
            if (overbuySelections[dateKey]) {
                delete overbuySelections[dateKey];
            }
        }
        
        // Clear current working date if it was deleted
        if (selectedDates.includes(currentWorkingDate)) {
            currentWorkingDate = null;
        }
        
        await ctx.editMessageText(`✅ အောက်ပါနေ့ရက်များ ဖျက်ပြီးပါပြီ:\n${selectedDates.join(', ')}`);
        
    } catch (e) {
        console.error(`Error in datedeleteConfirm: ${e.message}`);
        await ctx.editMessageText("❌ Error occurred");
    }
});

// Ignore callback
bot.action("ignore", async (ctx) => {
    await ctx.answerCbQuery();
});

// Start the bot
bot.launch().then(() => {
    console.log("🚀 Bot is starting...");
});

// Enable graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
