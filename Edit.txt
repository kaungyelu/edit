const { Telegraf, Markup } = require('telegraf');
const moment = require('moment-timezone');
const _ = require('lodash');

// Environment variable
const BOT_TOKEN = process.env.BOT_TOKEN;
if (!BOT_TOKEN) {
    console.error("âŒ BOT_TOKEN environment variable is not set");
    process.exit(1);
}

// Timezone setup
const MYANMAR_TIMEZONE = 'Asia/Yangon';

// Global data stores
let adminId = null;
const userData = {}; // {username: {date_key: [{num, amt}]}}
const ledger = {};    // {date_key: {number: total_amount}}
const breakLimits = {}; // {date_key: limit}
const pnumberPerDate = {}; // {date_key: power_number}
const dateControl = {}; // {date_key: true/false}
const overbuyList = {}; // {date_key: {username: {num: amount}}}
const messageStore = {}; // {`${user_id}_${message_id}`: {sentMessageId, bets, totalAmount, dateKey}}
const overbuySelections = {}; // {date_key: {username: {num: amount}}}
let currentWorkingDate = null; // For admin date selection

// Com and Za data
const comData = {};
const zaData = {};

const bot = new Telegraf(BOT_TOKEN);

// Utility functions
function reverseNumber(n) {
    const s = n.toString().padStart(2, '0');
    return parseInt(s.split('').reverse().join(''), 10);
}

function getTimeSegment() {
    const now = moment().tz(MYANMAR_TIMEZONE);
    return now.hours() < 12 ? 'AM' : 'PM';
}

function getCurrentDateKey() {
    const now = moment().tz(MYANMAR_TIMEZONE);
    return `${now.format('DD/MM/YYYY')} ${getTimeSegment()}`;
}

function getAvailableDates() {
    const dates = new Set();
    
    // Get dates from user data
    Object.values(userData).forEach(userDataDict => {
        Object.keys(userDataDict).forEach(date => dates.add(date));
    });
    
    // Get dates from ledger
    Object.keys(ledger).forEach(date => dates.add(date));
    
    // Get dates from break limits
    Object.keys(breakLimits).forEach(date => dates.add(date));
    
    // Get dates from pnumber
    Object.keys(pnumberPerDate).forEach(date => dates.add(date));
    
    return Array.from(dates).sort((a, b) => {
        const [dateA, timeA] = a.split(' ');
        const [dateB, timeB] = b.split(' ');
        const momentA = moment(`${dateA} ${timeA === 'AM' ? '00:00' : '12:00'}`, 'DD/MM/YYYY HH:mm');
        const momentB = moment(`${dateB} ${timeB === 'AM' ? '00:00' : '12:00'}`, 'DD/MM/YYYY HH:mm');
        return momentB - momentA;
    });
}

// Menu and command handlers
async function showMenu(ctx) {
    const keyboard = [];
    
    if (ctx.from.id === adminId) {
        keyboard.push(
            ["á€¡á€›á€±á€¬á€„á€ºá€¸á€–á€½á€„á€·á€ºá€›á€”á€º", "á€¡á€›á€±á€¬á€„á€ºá€¸á€•á€­á€á€ºá€›á€”á€º"],
            ["á€œá€Šá€ºá€á€»á€¬", "á€˜á€›á€­á€á€ºá€á€á€ºá€™á€¾á€á€ºá€›á€”á€º"],
            ["á€œá€»á€¾á€¶á€‚á€á€”á€ºá€¸á€™á€»á€¬á€¸á€á€šá€ºá€›á€”á€º", "á€•á€±á€«á€€á€ºá€á€®á€¸á€‘á€Šá€·á€ºá€›á€”á€º"],
            ["á€€á€±á€¬á€ºá€”á€¾á€„á€·á€ºá€¡á€† á€á€á€ºá€™á€¾á€á€ºá€›á€”á€º", "á€œá€€á€ºá€›á€¾á€­á€¡á€á€»á€­á€”á€ºá€™á€¾á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸"],
            ["á€‚á€á€”á€ºá€¸á€”á€¾á€„á€·á€ºá€„á€½á€±á€•á€±á€«á€„á€ºá€¸", "á€€á€±á€¬á€ºá€™á€›á€¾á€„á€ºá€™á€»á€¬á€¸"],
            ["á€›á€€á€ºá€á€»á€­á€”á€ºá€¸á€›á€”á€º", "á€á€…á€ºá€šá€±á€¬á€€á€ºá€á€¼á€„á€ºá€¸á€…á€¬á€›á€„á€ºá€¸"],
            ["á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€…á€¬á€›á€„á€ºá€¸á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸"],
            ["á€›á€€á€ºá€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€›á€”á€º", "á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€–á€»á€€á€ºá€›á€”á€º"]
        );
    } else {
        keyboard.push(["á€á€…á€ºá€šá€±á€¬á€€á€ºá€á€¼á€„á€ºá€¸á€…á€¬á€›á€„á€ºá€¸"]);
    }
    
    await ctx.reply("á€™á€®á€”á€°á€¸á€€á€­á€¯á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«", Markup.keyboard(keyboard).resize());
}

async function handleMenuSelection(ctx) {
    const text = ctx.message.text;
    const commandMap = {
        "á€¡á€›á€±á€¬á€„á€ºá€¸á€–á€½á€„á€·á€ºá€›á€”á€º": dateOpen,
        "á€¡á€›á€±á€¬á€„á€ºá€¸á€•á€­á€á€ºá€›á€”á€º": dateClose,
        "á€œá€Šá€ºá€á€»á€¬": ledgerSummary,
        "á€˜á€›á€­á€á€ºá€á€á€ºá€™á€¾á€á€ºá€›á€”á€º": breakCommand,
        "á€œá€»á€¾á€¶á€‚á€á€”á€ºá€¸á€™á€»á€¬á€¸á€á€šá€ºá€›á€”á€º": overbuy,
        "á€•á€±á€«á€€á€ºá€á€®á€¸á€‘á€Šá€·á€ºá€›á€”á€º": pnumber,
        "á€€á€±á€¬á€ºá€”á€¾á€„á€·á€ºá€¡á€† á€á€á€ºá€™á€¾á€á€ºá€›á€”á€º": comandza,
        "á€œá€€á€ºá€›á€¾á€­á€¡á€á€»á€­á€”á€ºá€™á€¾á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸": total,
        "á€‚á€á€”á€ºá€¸á€”á€¾á€„á€·á€ºá€„á€½á€±á€•á€±á€«á€„á€ºá€¸": tsent,
        "á€€á€±á€¬á€ºá€™á€›á€¾á€„á€ºá€™á€»á€¬á€¸": alldata,
        "á€›á€€á€ºá€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€›á€”á€º": resetData,
        "á€á€…á€ºá€šá€±á€¬á€€á€ºá€á€¼á€„á€ºá€¸á€…á€¬á€›á€„á€ºá€¸": posthis,
        "á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€…á€¬á€›á€„á€ºá€¸á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸": dateall,
        "á€›á€€á€ºá€á€»á€­á€”á€ºá€¸á€›á€”á€º": changeWorkingDate,
        "á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€–á€»á€€á€ºá€›á€”á€º": deleteDate
    };
    
    if (commandMap[text]) {
        await commandMap[text](ctx);
    }
}

// Start command
bot.start(async (ctx) => {
    adminId = ctx.from.id;
    currentWorkingDate = getCurrentDateKey();
    console.log(`Admin set to: ${adminId}`);
    await ctx.reply("ğŸ¤– Bot started. Admin privileges granted!");
    await showMenu(ctx);
});

// Date open/close commands
async function dateOpen(ctx) {
    if (ctx.from.id !== adminId) {
        await ctx.reply("âŒ Admin only command");
        return;
    }
    
    const key = getCurrentDateKey();
    dateControl[key] = true;
    console.log(`Ledger opened for ${key}`);
    await ctx.reply(`âœ… ${key} á€…á€¬á€›á€„á€ºá€¸á€–á€½á€„á€·á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®`);
}

async function dateClose(ctx) {
    if (ctx.from.id !== adminId) {
        await ctx.reply("âŒ Admin only command");
        return;
    }
    
    const key = getCurrentDateKey();
    dateControl[key] = false;
    console.log(`Ledger closed for ${key}`);
    await ctx.reply(`âœ… ${key} á€…á€¬á€›á€„á€ºá€¸á€•á€­á€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®`);
}

// Message handler
bot.on('text', async (ctx) => {
    try {
        const user = ctx.from;
        const text = ctx.message.text;
        
        if (!user || !user.username) {
            await ctx.reply("âŒ á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á Telegram username á€á€á€ºá€™á€¾á€á€ºá€•á€«");
            return;
        }

        const key = currentWorkingDate || getCurrentDateKey();
        if (!dateControl[key]) {
            await ctx.reply("âŒ á€…á€¬á€›á€„á€ºá€¸á€•á€­á€á€ºá€‘á€¬á€¸á€•á€«á€á€Šá€º");
            return;
        }

        if (!text) {
            await ctx.reply("âš ï¸ á€™á€€á€ºá€†á€±á€·á€‚á€»á€ºá€™á€›á€¾á€­á€•á€«");
            return;
        }

        // Process the message line by line
        const lines = text.split('\n');
        const allBets = [];
        let totalAmount = 0;

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            // Check for wheel cases first
            if (trimmedLine.includes('á€¡á€á€½á€±') || trimmedLine.includes('á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±')) {
                let basePart, amountPart;
                if (trimmedLine.includes('á€¡á€á€½á€±')) {
                    const parts = trimmedLine.split('á€¡á€á€½á€±');
                    basePart = parts[0];
                    amountPart = parts[1];
                } else {
                    const parts = trimmedLine.split('á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±');
                    basePart = parts[0];
                    amountPart = parts[1];
                }
                
                // Clean base numbers (remove all non-digits)
                const baseNumbers = basePart.replace(/\D/g, '');
                
                // Clean amount (remove all non-digits)
                const amount = parseInt(amountPart.replace(/\D/g, ''), 10);
                
                // Generate all possible pairs
                const pairs = [];
                for (let i = 0; i < baseNumbers.length; i++) {
                    for (let j = 0; j < baseNumbers.length; j++) {
                        if (i !== j) {
                            const num = parseInt(baseNumbers[i] + baseNumbers[j], 10);
                            if (!pairs.includes(num)) {
                                pairs.push(num);
                            }
                        }
                    }
                }
                
                // If á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±, add doubles
                if (trimmedLine.includes('á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±')) {
                    for (const d of baseNumbers) {
                        const double = parseInt(d + d, 10);
                        if (!pairs.includes(double)) {
                            pairs.push(double);
                        }
                    }
                }
                
                // Add all bets
                for (const num of pairs) {
                    allBets.push(`${num.toString().padStart(2, '0')}-${amount}`);
                    totalAmount += amount;
                }
                continue;
            }

            // Check for special cases
            const specialCases = {
                "á€¡á€•á€°á€¸": [0, 11, 22, 33, 44, 55, 66, 77, 88, 99],
                "á€•á€«á€á€«": [5, 16, 27, 38, 49, 50, 61, 72, 83, 94],
                "á€”á€€á€¹á€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€€á€ºá€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€ºá€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€ºá€á€€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€€á€ºá€á€€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€ºá€á€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€€á€ºá€á€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€•á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€Šá€®á€€á€­á€¯": [1, 12, 23, 34, 45, 56, 67, 78, 89, 90],
                "á€€á€­á€¯á€Šá€®": [9, 10, 21, 32, 43, 54, 65, 76, 87, 98],
            };

            const dynamicTypes = ["á€‘á€­á€•á€º", "á€•á€­á€á€º", "á€˜á€›á€­á€á€º", "á€¡á€•á€«"];
            
            // Check for special cases with flexible formatting
            let foundSpecial = false;
            for (const [caseName, caseNumbers] of Object.entries(specialCases)) {
                const caseVariations = [caseName];
                if (caseName === "á€”á€€á€¹á€") {
                    caseVariations.push("á€”á€", "á€”á€€á€ºá€", "á€”á€á€ºá€", "á€”á€á€€á€º", "á€”á€á€ºá€á€€á€º", "á€”á€€á€ºá€á€€á€º", "á€”á€á€ºá€á€á€º", "á€”á€€á€ºá€á€á€º", "á€”á€á€á€º", "á€”á€á€•á€º");
                }
                
                for (const variation of caseVariations) {
                    if (trimmedLine.startsWith(variation)) {
                        const amountStr = trimmedLine.slice(variation.length).trim().replace(/\D/g, '');
                        
                        if (amountStr && parseInt(amountStr, 10) >= 100) {
                            const amt = parseInt(amountStr, 10);
                            for (const num of caseNumbers) {
                                allBets.push(`${num.toString().padStart(2, '0')}-${amt}`);
                                totalAmount += amt;
                            }
                            foundSpecial = true;
                            break;
                        }
                    }
                    if (foundSpecial) break;
                }
                if (foundSpecial) break;
            }
            
            if (foundSpecial) continue;

            // Check for dynamic types with flexible formatting
            for (const dtype of dynamicTypes) {
                if (trimmedLine.includes(dtype)) {
                    const parts = trimmedLine.match(/\d+/g);
                    if (!parts || parts.length < 2) continue;
                    
                    const amount = parseInt(parts[parts.length - 1], 10);
                    if (amount < 100) continue;
                    
                    const digits = parts.slice(0, -1)
                        .filter(p => p.length === 1 && /\d/.test(p))
                        .map(p => parseInt(p, 10));
                    
                    if (digits.length === 0) continue;
                    
                    const numbers = [];
                    if (dtype === "á€‘á€­á€•á€º") {
                        for (const d of digits) {
                            for (let j = 0; j < 10; j++) {
                                numbers.push(d * 10 + j);
                            }
                        }
                    } else if (dtype === "á€•á€­á€á€º") {
                        for (const d of digits) {
                            for (let j = 0; j < 10; j++) {
                                numbers.push(j * 10 + d);
                            }
                        }
                    } else if (dtype === "á€˜á€›á€­á€á€º") {
                        for (const d of digits) {
                            for (let n = 0; n < 100; n++) {
                                if ((Math.floor(n / 10) + (n % 10)) % 10 === d) {
                                    numbers.push(n);
                                }
                            }
                        }
                    } else if (dtype === "á€¡á€•á€«") {
                        for (const d of digits) {
                            for (let j = 0; j < 10; j++) {
                                numbers.push(d * 10 + j);
                                numbers.push(j * 10 + d);
                            }
                        }
                    }
                    
                    // Remove duplicates
                    const uniqueNumbers = [...new Set(numbers)];
                    for (const num of uniqueNumbers) {
                        allBets.push(`${num.toString().padStart(2, '0')}-${amount}`);
                        totalAmount += amount;
                    }
                    foundSpecial = true;
                    break;
                }
            }
            
            if (foundSpecial) continue;

            // Process regular number-amount pairs with r/R (flexible formatting)
            if (/r/i.test(trimmedLine)) {
                const rPos = trimmedLine.toLowerCase().indexOf('r');
                const beforeR = trimmedLine.slice(0, rPos);
                const afterR = trimmedLine.slice(rPos + 1);
                
                const numsBefore = beforeR.match(/\d+/g) || [];
                const numsBeforeFiltered = numsBefore
                    .map(n => parseInt(n, 10))
                    .filter(n => n >= 0 && n <= 99);
                
                const amounts = afterR.match(/\d+/g) || [];
                const amountsFiltered = amounts
                    .map(a => parseInt(a, 10))
                    .filter(a => a >= 100);
                
                if (numsBeforeFiltered.length > 0 && amountsFiltered.length > 0) {
                    if (amountsFiltered.length === 1) {
                        // Single amount: apply to both base and reverse
                        for (const num of numsBeforeFiltered) {
                            allBets.push(`${num.toString().padStart(2, '0')}-${amountsFiltered[0]}`);
                            allBets.push(`${reverseNumber(num).toString().padStart(2, '0')}-${amountsFiltered[0]}`);
                            totalAmount += amountsFiltered[0] * 2;
                        }
                    } else {
                        // Two amounts: first for base, second for reverse
                        for (const num of numsBeforeFiltered) {
                            allBets.push(`${num.toString().padStart(2, '0')}-${amountsFiltered[0]}`);
                            allBets.push(`${reverseNumber(num).toString().padStart(2, '0')}-${amountsFiltered[1]}`);
                            totalAmount += amountsFiltered[0] + amountsFiltered[1];
                        }
                    }
                    continue;
                }
            }

            // Process regular number-amount pairs without r/R (flexible formatting)
            const allNumbers = trimmedLine.match(/\d+/g) || [];
            if (allNumbers.length === 0) continue;
            
            let amount = 0;
            const numbers = [];
            
            // Check if last number is amount (>=100)
            const lastNum = parseInt(allNumbers[allNumbers.length - 1], 10);
            if (lastNum >= 100) {
                amount = lastNum;
                // Other numbers are the bet numbers
                for (let i = 0; i < allNumbers.length - 1; i++) {
                    const n = parseInt(allNumbers[i], 10);
                    if (n >= 0 && n <= 99) {
                        numbers.push(n);
                    }
                }
            } else {
                // Maybe the line is just numbers separated by something
                // Try to find pairs where second number is >= 100
                for (let i = 0; i < allNumbers.length - 1; i++) {
                    const num = parseInt(allNumbers[i], 10);
                    const nextNum = parseInt(allNumbers[i + 1], 10);
                    if (num >= 0 && num <= 99 && nextNum >= 100) {
                        numbers.push(num);
                        amount = nextNum;
                        break;
                    }
                }
            }
            
            if (amount >= 100 && numbers.length > 0) {
                for (const num of numbers) {
                    allBets.push(`${num.toString().padStart(2, '0')}-${amount}`);
                    totalAmount += amount;
                }
            }
        }

        if (allBets.length === 0) {
            await ctx.reply("âš ï¸ á€¡á€á€»á€€á€ºá€¡á€œá€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯á€…á€…á€ºá€†á€±á€¸á€•á€«\ná€¥á€•á€™á€¬: 12-1000,12/34-1000 \n 12r1000,12r1000-500");
            return;
        }

        // Update data stores
        if (!userData[user.username]) {
            userData[user.username] = {};
        }
        if (!userData[user.username][key]) {
            userData[user.username][key] = [];
        }

        if (!ledger[key]) {
            ledger[key] = {};
        }

        for (const bet of allBets) {
            const [numStr, amtStr] = bet.split('-');
            const num = parseInt(numStr, 10);
            const amt = parseInt(amtStr, 10);
            
            // Update ledger
            if (!ledger[key][num]) {
                ledger[key][num] = 0;
            }
            ledger[key][num] += amt;
            
            // Update user data
            userData[user.username][key].push({ num, amt });
        }

        // Send confirmation with delete button
        const response = allBets.join('\n') + `\ná€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸ ${totalAmount} á€€á€»á€•á€º`;
        const keyboard = Markup.inlineKeyboard([
            Markup.button.callback('ğŸ—‘ Delete', `delete:${user.id}:${ctx.message.message_id}:${key}`)
        ]);
        
        const sentMessage = await ctx.reply(response, keyboard);
        messageStore[`${user.id}_${ctx.message.message_id}`] = {
            sentMessageId: sentMessage.message_id,
            bets: allBets,
            totalAmount,
            dateKey: key
        };
            
    } catch (e) {
        console.error(`Error in handleMessage: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
});

// Delete bet handlers
bot.action(/^delete:(\d+):(\d+):(.+)$/, async (ctx) => {
    try {
        const [_, userIdStr, messageIdStr, dateKey] = ctx.match;
        const userId = parseInt(userIdStr, 10);
        const messageId = parseInt(messageIdStr, 10);
        
        // Only admin can interact with delete button
        if (ctx.from.id !== adminId) {
            await ctx.editMessageText("âŒ Admin only action");
            return;
        }
            
        const keyboard = Markup.inlineKeyboard([
            [Markup.button.callback("âœ… OK", `confirm_delete:${userId}:${messageId}:${dateKey}`)],
            [Markup.button.callback("âŒ Cancel", `cancel_delete:${userId}:${messageId}:${dateKey}`)]
        ]);
        
        await ctx.editMessageText("âš ï¸ á€á€±á€á€»á€¬á€œá€¬á€¸? á€’á€®á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€€á€­á€¯á€–á€»á€€á€ºá€™á€¾á€¬á€œá€¬á€¸?", keyboard);
        
    } catch (e) {
        console.error(`Error in deleteBet: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred while processing deletion");
    }
});

bot.action(/^confirm_delete:(\d+):(\d+):(.+)$/, async (ctx) => {
    try {
        const [_, userIdStr, messageIdStr, dateKey] = ctx.match;
        const userId = parseInt(userIdStr, 10);
        const messageId = parseInt(messageIdStr, 10);
        const messageKey = `${userId}_${messageId}`;
        
        if (!messageStore[messageKey]) {
            await ctx.editMessageText("âŒ á€’á€±á€á€¬á€™á€á€½á€±á€·á€•á€«");
            return;
        }
            
        const { bets, totalAmount } = messageStore[messageKey];
        
        let username = null;
        for (const [uname, data] of Object.entries(userData)) {
            if (data[dateKey]) {
                for (const bet of data[dateKey]) {
                    if (bets.includes(`${bet.num.toString().padStart(2, '0')}-${bet.amt}`)) {
                        username = uname;
                        break;
                    }
                }
                if (username) break;
            }
        }
        
        if (!username) {
            await ctx.editMessageText("âŒ User á€™á€á€½á€±á€·á€•á€«");
            return;
        }
        
        for (const bet of bets) {
            const [numStr, amtStr] = bet.split('-');
            const num = parseInt(numStr, 10);
            const amt = parseInt(amtStr, 10);
            
            if (ledger[dateKey] && ledger[dateKey][num]) {
                ledger[dateKey][num] -= amt;
                if (ledger[dateKey][num] <= 0) {
                    delete ledger[dateKey][num];
                }
                // Remove date from ledger if empty
                if (Object.keys(ledger[dateKey]).length === 0) {
                    delete ledger[dateKey];
                }
            }
            
            if (userData[username] && userData[username][dateKey]) {
                userData[username][dateKey] = userData[username][dateKey].filter(
                    ({ num: n, amt: a }) => !(n === num && a === amt)
                );
                
                if (userData[username][dateKey].length === 0) {
                    delete userData[username][dateKey];
                    if (Object.keys(userData[username]).length === 0) {
                        delete userData[username];
                    }
                }
            }
        }
        
        delete messageStore[messageKey];
        await ctx.editMessageText("âœ… á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®");
        
    } catch (e) {
        console.error(`Error in confirmDelete: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred while deleting bet");
    }
});

bot.action(/^cancel_delete:(\d+):(\d+):(.+)$/, async (ctx) => {
    try {
        const [_, userIdStr, messageIdStr, dateKey] = ctx.match;
        const userId = parseInt(userIdStr, 10);
        const messageId = parseInt(messageIdStr, 10);
        const messageKey = `${userId}_${messageId}`;
        
        if (messageStore[messageKey]) {
            const { bets, totalAmount } = messageStore[messageKey];
            const response = bets.join('\n') + `\ná€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸ ${totalAmount} á€€á€»á€•á€º`;
            const keyboard = Markup.inlineKeyboard([
                Markup.button.callback('ğŸ—‘ Delete', `delete:${userId}:${messageId}:${dateKey}`)
            ]);
            await ctx.editMessageText(response, keyboard);
        } else {
            await ctx.editMessageText("â„¹ï¸ á€–á€»á€€á€ºá€á€¼á€„á€ºá€¸á€€á€­á€¯á€•á€šá€ºá€–á€»á€€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®");
        }
            
    } catch (e) {
        console.error(`Error in cancelDelete: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred while canceling deletion");
    }
});

// Ledger summary
async function ledgerSummary(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Determine which date to show
        const dateKey = currentWorkingDate || getCurrentDateKey();
        
        if (!ledger[dateKey]) {
            await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€œá€€á€ºá€›á€¾á€­á€á€½á€„á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€•á€«`);
            return;
        }
            
        const lines = [`ğŸ“’ ${dateKey} á€œá€€á€ºá€€á€»á€”á€ºá€„á€½á€±á€…á€¬á€›á€„á€ºá€¸`];
        const ledgerData = ledger[dateKey];
        
        let totalAllNumbers = 0; // á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€„á€½á€±á€¡á€á€½á€€á€º
        
        for (let i = 0; i < 100; i++) {
            const total = ledgerData[i] || 0;
            if (total > 0) {
                if (pnumberPerDate[dateKey] === i) {
                    lines.push(`ğŸ”´ ${i.toString().padStart(2, '0')} â¤ ${total} ğŸ”´`);
                } else {
                    lines.push(`${i.toString().padStart(2, '0')} â¤ ${total}`);
                }
                totalAllNumbers += total;
            }
        }

        if (lines.length === 1) {
            await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€œá€€á€ºá€›á€¾á€­á€á€½á€„á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€•á€«`);
        } else {
            if (pnumberPerDate[dateKey] !== undefined) {
                const pnum = pnumberPerDate[dateKey];
                lines.push(`\nğŸ”´ Power Number: ${pnum.toString().padStart(2, '0')} â¤ ${ledgerData[pnum] || 0}`);
            }
            
            // á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€„á€½á€±á€•á€¼á€›á€”á€º á€¡á€±á€¬á€€á€ºá€á€¼á€±á€á€½á€„á€º á€‘á€Šá€·á€ºá€•á€«
            lines.push(`\nğŸ’° á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${totalAllNumbers} á€€á€»á€•á€º`);
            await ctx.reply(lines.join('\n'));
        }
    } catch (e) {
        console.error(`Error in ledger: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Break command
async function breakCommand(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (ctx.message.text.split(' ').length < 2) {
            if (breakLimits[dateKey]) {
                await ctx.reply(`â„¹ï¸ Usage: /break [limit]\nâ„¹ï¸ á€œá€€á€ºá€›á€¾á€­á€á€½á€„á€º break limit: ${breakLimits[dateKey]}`);
            } else {
                await ctx.reply(`â„¹ï¸ Usage: /break [limit]\nâ„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º break limit á€™á€á€á€ºá€™á€¾á€á€ºá€›á€á€±á€¸á€•á€«`);
            }
            return;
        }
            
        try {
            const newLimit = parseInt(ctx.message.text.split(' ')[1], 10);
            breakLimits[dateKey] = newLimit;
            await ctx.reply(`âœ… ${dateKey} á€¡á€á€½á€€á€º Break limit á€€á€­á€¯ ${newLimit} á€¡á€–á€¼á€…á€ºá€á€á€ºá€™á€¾á€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®`);
            
            if (!ledger[dateKey]) {
                await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€á€±á€¸á€•á€«`);
                return;
            }
                
            const ledgerData = ledger[dateKey];
            const msg = [`ğŸ“Œ ${dateKey} á€¡á€á€½á€€á€º Limit (${newLimit}) á€€á€»á€±á€¬á€ºá€‚á€á€”á€ºá€¸á€™á€»á€¬á€¸:`];
            let found = false;
            
            for (const [num, amt] of Object.entries(ledgerData)) {
                if (amt > newLimit) {
                    msg.push(`${num.toString().padStart(2, '0')} â¤ ${amt - newLimit}`);
                    found = true;
                }
            }
            
            if (!found) {
                await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€˜á€šá€ºá€‚á€á€”á€ºá€¸á€™á€¾ limit (${newLimit}) á€™á€€á€»á€±á€¬á€ºá€•á€«`);
            } else {
                await ctx.reply(msg.join('\n'));
            }
                
        } catch (e) {
            await ctx.reply("âš ï¸ Limit amount á€‘á€Šá€·á€ºá€•á€« (á€¥á€•á€™á€¬: /break 5000)");
        }
            
    } catch (e) {
        console.error(`Error in break: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Overbuy command
async function overbuy(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (ctx.message.text.split(' ').length < 2) {
            await ctx.reply("â„¹ï¸ á€€á€¬á€’á€­á€¯á€„á€ºá€¡á€™á€Šá€ºá€‘á€Šá€·á€ºá€•á€«");
            return;
        }
            
        if (!breakLimits[dateKey]) {
            await ctx.reply(`âš ï¸ ${dateKey} á€¡á€á€½á€€á€º á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á /break [limit] á€–á€¼á€„á€·á€º limit á€á€á€ºá€™á€¾á€á€ºá€•á€«`);
            return;
        }
            
        if (!ledger[dateKey]) {
            await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€á€±á€¸á€•á€«`);
            return;
        }
            
        const username = ctx.message.text.split(' ')[1];
        ctx.session = ctx.session || {};
        ctx.session.overbuyUsername = username;
        ctx.session.overbuyDate = dateKey;
        
        const ledgerData = ledger[dateKey];
        const breakLimitVal = breakLimits[dateKey];
        const overNumbers = {};
        
        for (const [num, amt] of Object.entries(ledgerData)) {
            if (amt > breakLimitVal) {
                overNumbers[num] = amt - breakLimitVal;
            }
        }
        
        if (Object.keys(overNumbers).length === 0) {
            await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€˜á€šá€ºá€‚á€á€”á€ºá€¸á€™á€¾ limit (${breakLimitVal}) á€™á€€á€»á€±á€¬á€ºá€•á€«`);
            return;
        }
            
        if (!overbuySelections[dateKey]) {
            overbuySelections[dateKey] = {};
        }
        overbuySelections[dateKey][username] = _.cloneDeep(overNumbers);
        
        const msg = [`${username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: ${dateKey}, Limit: ${breakLimitVal}):`];
        const buttons = [];
        
        for (const [num, amt] of Object.entries(overNumbers)) {
            buttons.push([
                Markup.button.callback(
                    `${num.toString().padStart(2, '0')} â¤ ${amt} ${overbuySelections[dateKey][username][num] ? 'âœ…' : 'â¬œ'}`,
                    `overbuy_select:${num}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.reply(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuy: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Overbuy selection handlers
bot.action(/^overbuy_select:(\d+)$/, async (ctx) => {
    try {
        const [_, numStr] = ctx.match;
        const num = parseInt(numStr, 10);
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("âŒ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey] || !overbuySelections[dateKey][username]) {
            await ctx.editMessageText("âŒ Error: Selection data not found");
            return;
        }
            
        if (overbuySelections[dateKey][username][num]) {
            delete overbuySelections[dateKey][username][num];
        } else {
            const breakLimitVal = breakLimits[dateKey];
            overbuySelections[dateKey][username][num] = ledger[dateKey][num] - breakLimitVal;
        }
            
        const msg = [`${username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: ${dateKey}):`];
        const buttons = [];
        
        for (const [n, amt] of Object.entries(overbuySelections[dateKey][username])) {
            buttons.push([
                Markup.button.callback(
                    `${n.toString().padStart(2, '0')} â¤ ${amt} ${overbuySelections[dateKey][username][n] ? 'âœ…' : 'â¬œ'}`,
                    `overbuy_select:${n}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuySelect: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("overbuy_select_all", async (ctx) => {
    try {
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("âŒ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey]) {
            overbuySelections[dateKey] = {};
        }
            
        const breakLimitVal = breakLimits[dateKey];
        const ledgerData = ledger[dateKey];
        overbuySelections[dateKey][username] = {};
        
        for (const [num, amt] of Object.entries(ledgerData)) {
            if (amt > breakLimitVal) {
                overbuySelections[dateKey][username][num] = amt - breakLimitVal;
            }
        }
        
        const msg = [`${username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: ${dateKey}):`];
        const buttons = [];
        
        for (const [num, amt] of Object.entries(overbuySelections[dateKey][username])) {
            buttons.push([
                Markup.button.callback(
                    `${num.toString().padStart(2, '0')} â¤ ${amt} âœ…`,
                    `overbuy_select:${num}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuySelectAll: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("overbuy_unselect_all", async (ctx) => {
    try {
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("âŒ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey]) {
            overbuySelections[dateKey] = {};
        }
            
        overbuySelections[dateKey][username] = {};
        
        const breakLimitVal = breakLimits[dateKey];
        const ledgerData = ledger[dateKey];
        const overNumbers = {};
        
        for (const [num, amt] of Object.entries(ledgerData)) {
            if (amt > breakLimitVal) {
                overNumbers[num] = amt - breakLimitVal;
            }
        }
        
        const msg = [`${username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: ${dateKey}):`];
        const buttons = [];
        
        for (const [num, amt] of Object.entries(overNumbers)) {
            buttons.push([
                Markup.button.callback(
                    `${num.toString().padStart(2, '0')} â¤ ${amt} â¬œ`,
                    `overbuy_select:${num}`
                )
            ]);
        }
        
        buttons.push([
            Markup.button.callback("Select All", "overbuy_select_all"),
            Markup.button.callback("Unselect All", "overbuy_unselect_all")
        ]);
        buttons.push([Markup.button.callback("OK", "overbuy_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in overbuyUnselectAll: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("overbuy_confirm", async (ctx) => {
    try {
        const username = ctx.session?.overbuyUsername;
        const dateKey = ctx.session?.overbuyDate;
        
        if (!username || !dateKey) {
            await ctx.editMessageText("âŒ Error: User or date not found");
            return;
        }
            
        if (!overbuySelections[dateKey] || !overbuySelections[dateKey][username]) {
            await ctx.editMessageText("âŒ Error: Selection data not found");
            return;
        }
            
        const selectedNumbers = overbuySelections[dateKey][username];
        if (Object.keys(selectedNumbers).length === 0) {
            await ctx.editMessageText("âš ï¸ á€˜á€¬á€‚á€á€”á€ºá€¸á€™á€¾á€™á€›á€½á€±á€¸á€‘á€¬á€¸á€•á€«");
            return;
        }
            
        if (!userData[username]) {
            userData[username] = {};
        }
        if (!userData[username][dateKey]) {
            userData[username][dateKey] = [];
        }
            
        let totalAmount = 0;
        const bets = [];
        for (const [numStr, amt] of Object.entries(selectedNumbers)) {
            const num = parseInt(numStr, 10);
            userData[username][dateKey].push({ num, amt: -amt });
            bets.push(`${num.toString().padStart(2, '0')}-${amt}`);
            totalAmount += amt;
            
            // Update ledger
            ledger[dateKey][num] = (ledger[dateKey][num] || 0) - amt;
            if (ledger[dateKey][num] <= 0) {
                delete ledger[dateKey][num];
            }
        }
        
        // Initialize overbuy_list for date if needed
        if (!overbuyList[dateKey]) {
            overbuyList[dateKey] = {};
        }
        overbuyList[dateKey][username] = _.cloneDeep(selectedNumbers);
        
        const response = `${username} - ${dateKey}\n` + bets.join('\n') + `\ná€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸ ${totalAmount} á€€á€»á€•á€º`;
        await ctx.editMessageText(response);
        
    } catch (e) {
        console.error(`Error in overbuyConfirm: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

// Pnumber command
async function pnumber(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (ctx.message.text.split(' ').length < 2) {
            if (pnumberPerDate[dateKey] !== undefined) {
                await ctx.reply(`â„¹ï¸ Usage: /pnumber [number]\nâ„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º Power Number: ${pnumberPerDate[dateKey].toString().padStart(2, '0')}`);
            } else {
                await ctx.reply(`â„¹ï¸ Usage: /pnumber [number]\nâ„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º Power Number á€™á€á€á€ºá€™á€¾á€á€ºá€›á€á€±á€¸á€•á€«`);
            }
            return;
        }
            
        try {
            const num = parseInt(ctx.message.text.split(' ')[1], 10);
            if (num < 0 || num > 99) {
                await ctx.reply("âš ï¸ á€‚á€á€”á€ºá€¸á€€á€­á€¯ 0 á€”á€¾á€„á€·á€º 99 á€€á€¼á€¬á€¸á€‘á€Šá€·á€ºá€•á€«");
                return;
            }
                
            pnumberPerDate[dateKey] = num;
            await ctx.reply(`âœ… ${dateKey} á€¡á€á€½á€€á€º Power Number á€€á€­á€¯ ${num.toString().padStart(2, '0')} á€¡á€–á€¼á€…á€ºá€á€á€ºá€™á€¾á€á€ºá€•á€¼á€®á€¸`);
            
            // Show report for this date
            const msg = [];
            let totalPower = 0;
            
            for (const [user, records] of Object.entries(userData)) {
                if (records[dateKey]) {
                    let userTotal = 0;
                    for (const { num: betNum, amt } of records[dateKey]) {
                        if (betNum === num) {
                            userTotal += amt;
                        }
                    }
                    if (userTotal > 0) {
                        msg.push(`${user}: ${num.toString().padStart(2, '0')} â¤ ${userTotal}`);
                        totalPower += userTotal;
                    }
                }
            }
            
            if (msg.length > 0) {
                msg.push(`\nğŸ”´ ${dateKey} á€¡á€á€½á€€á€º Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${totalPower}`);
                await ctx.reply(msg.join('\n'));
            } else {
                await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º ${num.toString().padStart(2, '0')} á€¡á€á€½á€€á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€•á€«`);
            }
                
        } catch (e) {
            await ctx.reply("âš ï¸ á€‚á€á€”á€ºá€¸á€™á€¾á€”á€ºá€™á€¾á€”á€ºá€‘á€Šá€·á€ºá€•á€« (á€¥á€•á€™á€¬: /pnumber 15)");
        }
            
    } catch (e) {
        console.error(`Error in pnumber: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Comandza command
async function comandza(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­ user á€™á€›á€¾á€­á€•á€«");
            return;
        }
            
        const users = Object.keys(userData);
        const buttons = users.map(u => [Markup.button.callback(u, `comza:${u}`)]);
        await ctx.reply("ğŸ‘‰ User á€€á€­á€¯á€›á€½á€±á€¸á€•á€«", Markup.inlineKeyboard(buttons));
    } catch (e) {
        console.error(`Error in comandza: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

bot.action(/^comza:(.+)$/, async (ctx) => {
    try {
        const username = ctx.match[1];
        ctx.session = ctx.session || {};
        ctx.session.selectedUser = username;
        await ctx.editMessageText(`ğŸ‘‰ ${username} á€€á€­á€¯á€›á€½á€±á€¸á€‘á€¬á€¸á€á€Šá€ºá‹ 15/80 á€œá€­á€¯á€·á€‘á€Šá€·á€ºá€•á€«`);
    } catch (e) {
        console.error(`Error in comzaInput: ${e.message}`);
        await ctx.editMessageText(`âŒ Error: ${e.message}`);
    }
});

// Comza text handler
bot.on('text', async (ctx) => {
    try {
        if (!ctx.session?.selectedUser) return;
        
        const user = ctx.session.selectedUser;
        const text = ctx.message.text;
        
        if (text && text.includes('/')) {
            try {
                const parts = text.split('/');
                if (parts.length !== 2) throw new Error();
                
                const com = parseInt(parts[0], 10);
                const za = parseInt(parts[1], 10);
                
                if (com < 0 || com > 100 || za < 0) throw new Error();
                    
                comData[user] = com;
                zaData[user] = za;
                delete ctx.session.selectedUser;
                await ctx.reply(`âœ… Com ${com}%, Za ${za} á€™á€¾á€á€ºá€‘á€¬á€¸á€•á€¼á€®á€¸`);
            } catch (e) {
                await ctx.reply("âš ï¸ á€™á€¾á€”á€ºá€™á€¾á€”á€ºá€›á€±á€¸á€•á€« (á€¥á€•á€™á€¬: 15/80)");
            }
        }
    } catch (e) {
        console.error(`Error in comzaText: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
});

// Total command
async function total(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (pnumberPerDate[dateKey] === undefined) {
            await ctx.reply(`âš ï¸ ${dateKey} á€¡á€á€½á€€á€º á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á /pnumber [number] á€–á€¼á€„á€·á€º Power Number á€á€á€ºá€™á€¾á€á€ºá€•á€«`);
            return;
        }
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«");
            return;
        }
            
        const pnum = pnumberPerDate[dateKey];
        const msg = [`ğŸ“Š ${dateKey} á€¡á€á€½á€€á€º á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º`];
        let totalNet = 0;
        
        for (const [user, records] of Object.entries(userData)) {
            if (records[dateKey]) {
                let userTotalAmt = 0;
                let userPamt = 0;
                
                for (const { num, amt } of records[dateKey]) {
                    userTotalAmt += amt;
                    if (num === pnum) {
                        userPamt += amt;
                    }
                }
                
                const com = comData[user] || 0;
                const za = zaData[user] || 80;
                
                const commissionAmt = Math.floor((userTotalAmt * com) / 100);
                const afterCom = userTotalAmt - commissionAmt;
                const winAmt = userPamt * za;
                
                const net = afterCom - winAmt;
                const status = net < 0 ? "á€’á€­á€¯á€„á€ºá€€á€•á€±á€¸á€›á€™á€Šá€º" : "á€’á€­á€¯á€„á€ºá€€á€›á€™á€Šá€º";
                
                const userReport = [
                    `ğŸ‘¤ ${user}`,
                    `ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${userTotalAmt}`,
                    `ğŸ“Š Com(${com}%) â¤ ${commissionAmt}`,
                    `ğŸ’° Com á€•á€¼á€®á€¸: ${afterCom}`,
                    `ğŸ”¢ Power Number(${pnum.toString().padStart(2, '0')}) â¤ ${userPamt}`,
                    `ğŸ¯ Za(${za}) â¤ ${winAmt}`,
                    `ğŸ“ˆ á€›á€œá€’á€º: ${Math.abs(net)} (${status})`,
                    "-----------------"
                ].join('\n');
                
                msg.push(userReport);
                totalNet += net;
            }
        }

        if (msg.length > 1) {
            msg.push(`\nğŸ“Š á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º: ${Math.abs(totalNet)} (${totalNet < 0 ? 'á€’á€­á€¯á€„á€ºá€¡á€›á€¾á€¯á€¶á€¸' : 'á€’á€­á€¯á€„á€ºá€¡á€™á€¼á€á€º'})`);
            await ctx.reply(msg.join('\n'));
        } else {
            await ctx.reply(`â„¹ï¸ ${dateKey} á€¡á€á€½á€€á€º á€’á€±á€á€¬á€™á€›á€¾á€­á€•á€«`);
        }
    } catch (e) {
        console.error(`Error in total: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Tsent command
async function tsent(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Determine which date to work on
        const dateKey = currentWorkingDate || getCurrentDateKey();
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­ user á€™á€›á€¾á€­á€•á€«");
            return;
        }
            
        for (const user in userData) {
            if (userData[user][dateKey]) {
                const userReport = [`ğŸ‘¤ ${user} - ${dateKey}:`];
                let totalAmt = 0;
                
                for (const { num, amt } of userData[user][dateKey]) {
                    userReport.push(`  - ${num.toString().padStart(2, '0')} â¤ ${amt}`);
                    totalAmt += amt;
                }
                
                userReport.push(`ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${totalAmt}`);
                await ctx.reply(userReport.join('\n'));
            }
        }
        
        await ctx.reply(`âœ… ${dateKey} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€»á€¬á€¸á€¡á€¬á€¸á€œá€¯á€¶á€¸ á€•á€±á€¸á€•á€­á€¯á€·á€•á€¼á€®á€¸á€•á€«á€•á€¼á€®`);
    } catch (e) {
        console.error(`Error in tsent: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Alldata command
async function alldata(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        if (Object.keys(userData).length === 0) {
            await ctx.reply("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«");
            return;
        }
            
        const msg = ["ğŸ‘¥ á€™á€¾á€á€ºá€•á€¯á€¶á€á€„á€ºá€‘á€¬á€¸á€á€±á€¬ user á€™á€»á€¬á€¸:"];
        msg.push(...Object.keys(userData).map(u => `â€¢ ${u}`));
        
        await ctx.reply(msg.join('\n'));
    } catch (e) {
        console.error(`Error in alldata: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Reset data command
async function resetData(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Clear all data
        Object.keys(userData).forEach(key => delete userData[key]);
        Object.keys(ledger).forEach(key => delete ledger[key]);
        Object.keys(zaData).forEach(key => delete zaData[key]);
        Object.keys(comData).forEach(key => delete comData[key]);
        Object.keys(dateControl).forEach(key => delete dateControl[key]);
        Object.keys(overbuyList).forEach(key => delete overbuyList[key]);
        Object.keys(overbuySelections).forEach(key => delete overbuySelections[key]);
        Object.keys(breakLimits).forEach(key => delete breakLimits[key]);
        Object.keys(pnumberPerDate).forEach(key => delete pnumberPerDate[key]);
        
        currentWorkingDate = getCurrentDateKey();
        
        await ctx.reply("âœ… á€’á€±á€á€¬á€™á€»á€¬á€¸á€¡á€¬á€¸á€œá€¯á€¶á€¸á€€á€­á€¯ á€•á€¼á€”á€ºá€œá€Šá€ºá€á€¯á€á€ºá€á€„á€ºá€•á€¼á€®á€¸ á€œá€€á€ºá€›á€¾á€­á€”á€±á€·á€á€­á€¯á€·á€•á€¼á€”á€ºá€œá€Šá€ºá€á€á€ºá€™á€¾á€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®");
    } catch (e) {
        console.error(`Error in resetData: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Posthis command
async function posthis(ctx) {
    try {
        const isAdmin = ctx.from.id === adminId;
        let username;
        
        if (isAdmin && ctx.message.text.split(' ').length < 2) {
            if (Object.keys(userData).length === 0) {
                await ctx.reply("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­ user á€™á€›á€¾á€­á€•á€«");
                return;
            }
                
            const buttons = Object.keys(userData).map(u => [Markup.button.callback(u, `posthis:${u}`)]);
            await ctx.reply(
                "á€˜á€šá€º user á€›á€²á€·á€…á€¬á€›á€„á€ºá€¸á€€á€­á€¯á€€á€¼á€Šá€·á€ºá€™á€œá€²?",
                Markup.inlineKeyboard(buttons)
            );
            return;
        }
        
        username = isAdmin ? ctx.message.text.split(' ')[1] : ctx.from.username;
        
        if (!username) {
            await ctx.reply("âŒ User á€™á€›á€¾á€­á€•á€«");
            return;
        }
            
        if (!userData[username]) {
            await ctx.reply(`â„¹ï¸ ${username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«`);
            return;
        }
            
        // For non-admin, show current date only
        const dateKey = isAdmin ? null : getCurrentDateKey();
        
        const msg = [`ğŸ“Š ${username} á€›á€²á€·á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€¾á€á€ºá€á€™á€ºá€¸`];
        let totalAmount = 0;
        let pnumberTotal = 0;
        
        if (isAdmin) {
            // Admin can see all dates
            for (const [dateKey, records] of Object.entries(userData[username])) {
                const pnum = pnumberPerDate[dateKey];
                const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
                
                msg.push(`\nğŸ“… ${dateKey}${pnumStr}:`);
                for (const { num, amt } of records) {
                    if (pnum !== undefined && num === pnum) {
                        msg.push(`ğŸ”´ ${num.toString().padStart(2, '0')} â¤ ${amt} ğŸ”´`);
                        pnumberTotal += amt;
                    } else {
                        msg.push(`${num.toString().padStart(2, '0')} â¤ ${amt}`);
                    }
                    totalAmount += amt;
                }
            }
        } else {
            // Non-admin only sees current date
            if (userData[username][dateKey]) {
                const pnum = pnumberPerDate[dateKey];
                const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
                
                msg.push(`\nğŸ“… ${dateKey}${pnumStr}:`);
                for (const { num, amt } of userData[username][dateKey]) {
                    if (pnum !== undefined && num === pnum) {
                        msg.push(`ğŸ”´ ${num.toString().padStart(2, '0')} â¤ ${amt} ğŸ”´`);
                        pnumberTotal += amt;
                    } else {
                        msg.push(`${num.toString().padStart(2, '0')} â¤ ${amt}`);
                    }
                    totalAmount += amt;
                }
            }
        }
        
        if (msg.length > 1) {
            msg.push(`\nğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${totalAmount}`);
            if (pnumberTotal > 0) {
                msg.push(`ğŸ”´ Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${pnumberTotal}`);
            }
            await ctx.reply(msg.join('\n'));
        } else {
            await ctx.reply(`â„¹ï¸ ${username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«`);
        }
        
    } catch (e) {
        console.error(`Error in posthis: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

bot.action(/^posthis:(.+)$/, async (ctx) => {
    try {
        const username = ctx.match[1];
        const msg = [`ğŸ“Š ${username} á€›á€²á€·á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€¾á€á€ºá€á€™á€ºá€¸`];
        let totalAmount = 0;
        let pnumberTotal = 0;
        
        if (userData[username]) {
            for (const [dateKey, records] of Object.entries(userData[username])) {
                const pnum = pnumberPerDate[dateKey];
                const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
                
                msg.push(`\nğŸ“… ${dateKey}${pnumStr}:`);
                for (const { num, amt } of records) {
                    if (pnum !== undefined && num === pnum) {
                        msg.push(`ğŸ”´ ${num.toString().padStart(2, '0')} â¤ ${amt} ğŸ”´`);
                        pnumberTotal += amt;
                    } else {
                        msg.push(`${num.toString().padStart(2, '0')} â¤ ${amt}`);
                    }
                    totalAmount += amt;
                }
            }
            
            if (msg.length > 1) {
                msg.push(`\nğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${totalAmount}`);
                if (pnumberTotal > 0) {
                    msg.push(`ğŸ”´ Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${pnumberTotal}`);
                }
                await ctx.editMessageText(msg.join('\n'));
            } else {
                await ctx.editMessageText(`â„¹ï¸ ${username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«`);
            }
        } else {
            await ctx.editMessageText(`â„¹ï¸ ${username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«`);
        }
            
    } catch (e) {
        console.error(`Error in posthisCallback: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

// Dateall command
async function dateall(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Get all unique dates from user_data
        const allDates = getAvailableDates();
        
        if (allDates.length === 0) {
            await ctx.reply("â„¹ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€…á€¬á€›á€„á€ºá€¸á€™á€¾ á€™á€›á€¾á€­á€á€±á€¸á€•á€«");
            return;
        }
            
        // Initialize selection dictionary
        const dateallSelections = {};
        allDates.forEach(date => dateallSelections[date] = false);
        ctx.session = ctx.session || {};
        ctx.session.dateallSelections = dateallSelections;
        
        // Build message with checkboxes
        const msg = ["ğŸ“… á€…á€¬á€›á€„á€ºá€¸á€›á€¾á€­á€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"];
        const buttons = [];
        
        for (const date of allDates) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = dateallSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? 'âœ…' : 'â¬œ'}`,
                    `dateall_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("ğŸ‘â€ğŸ—¨ View", "dateall_view")]);
        
        await ctx.reply(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in dateall: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

bot.action(/^dateall_toggle:(.+)$/, async (ctx) => {
    try {
        const dateKey = ctx.match[1];
        const dateallSelections = ctx.session?.dateallSelections || {};
        
        if (!dateallSelections[dateKey]) {
            await ctx.editMessageText("âŒ Error: Date not found");
            return;
        }
            
        // Toggle selection status
        dateallSelections[dateKey] = !dateallSelections[dateKey];
        ctx.session.dateallSelections = dateallSelections;
        
        // Rebuild the message with updated selections
        const msg = ["ğŸ“… á€…á€¬á€›á€„á€ºá€¸á€›á€¾á€­á€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"];
        const buttons = [];
        
        for (const date in dateallSelections) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = dateallSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? 'âœ…' : 'â¬œ'}`,
                    `dateall_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("ğŸ‘â€ğŸ—¨ View", "dateall_view")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in dateallToggle: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("dateall_view", async (ctx) => {
    try {
        // 1. Get selected dates
        const dateallSelections = ctx.session?.dateallSelections || {};
        const selectedDates = Object.entries(dateallSelections)
            .filter(([_, selected]) => selected)
            .map(([date]) => date);
        
        if (selectedDates.length === 0) {
            await ctx.editMessageText("âš ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯á€™á€¾ á€™á€›á€½á€±á€¸á€á€»á€šá€ºá€‘á€¬á€¸á€•á€«");
            return;
        }

        // 2. Initialize data storage
        const userReports = {};  // {username: {totalBet: 0, powerBet: 0, com: X, za: Y}}
        const grandTotals = {
            totalBet: 0,
            powerBet: 0,
            commission: 0,
            winAmount: 0,
            netResult: 0
        };

        // 3. Process bets WITHOUT overbuy adjustment
        for (const [username, userDates] of Object.entries(userData)) {
            if (!userReports[username]) {
                userReports[username] = {
                    totalBet: 0,
                    powerBet: 0,
                    com: comData[username] || 0,
                    za: zaData[username] || 80
                };
            }
            
            for (const dateKey of selectedDates) {
                if (userDates[dateKey]) {
                    // Track total bets
                    const dateTotal = userDates[dateKey].reduce((sum, { amt }) => sum + amt, 0);
                    userReports[username].totalBet += dateTotal;
                    
                    // Track power number bets
                    const pnum = pnumberPerDate[dateKey];
                    if (pnum !== undefined) {
                        const powerAmt = userDates[dateKey]
                            .filter(({ num }) => num === pnum)
                            .reduce((sum, { amt }) => sum + amt, 0);
                        userReports[username].powerBet += powerAmt;
                    }
                }
            }
        }

        // 4. Calculate financials
        const messages = ["ğŸ“Š á€›á€½á€±á€¸á€á€»á€šá€ºá€‘á€¬á€¸á€á€±á€¬ á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º (Overbuy á€™á€•á€«)"];
        messages.push(`ğŸ“… á€›á€€á€ºá€…á€½á€²á€™á€»á€¬á€¸: ${selectedDates.join(', ')}\n`);
        
        for (const [username, report] of Object.entries(userReports)) {
            // Calculate values
            const commission = Math.floor((report.totalBet * report.com) / 100);
            const afterCom = report.totalBet - commission;
            const winAmount = report.powerBet * report.za;
            const netResult = afterCom - winAmount;
            
            // Build user message
            const userMsg = [
                `ğŸ‘¤ ${username}`,
                `ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸: ${report.totalBet}`,
                `ğŸ“Š Com (${report.com}%): ${commission}`,
                `ğŸ’° Com á€•á€¼á€®á€¸: ${afterCom}`
            ];
            
            if (report.powerBet > 0) {
                userMsg.push(
                    `ğŸ”´ Power Number: ${report.powerBet}`,
                    `ğŸ¯ Za (${report.za}): ${winAmount}`
                );
            }
            
            userMsg.push(
                `ğŸ“ˆ á€›á€œá€’á€º: ${Math.abs(netResult)} (${netResult < 0 ? 'á€’á€­á€¯á€„á€ºá€€á€•á€±á€¸á€›á€”á€º' : 'á€’á€­á€¯á€„á€ºá€€á€›á€™á€Šá€º'})`
            );
            
            messages.push(userMsg.join('\n'));
            messages.push("â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯");
            
            // Update grand totals
            grandTotals.totalBet += report.totalBet;
            grandTotals.powerBet += report.powerBet;
            grandTotals.commission += commission;
            grandTotals.winAmount += winAmount;
            grandTotals.netResult += netResult;
        }

        // 5. Add grand totals
        messages.push("\nğŸ“Œ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º:");
        messages.push(`ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸: ${grandTotals.totalBet}`);
        messages.push(`ğŸ“Š Com á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${grandTotals.commission}`);
        
        if (grandTotals.powerBet > 0) {
            messages.push(`ğŸ”´ Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${grandTotals.powerBet}`);
            messages.push(`ğŸ¯ Win Amount á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: ${grandTotals.winAmount}`);
        }
        
        messages.push(
            `ğŸ“Š á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º: ${Math.abs(grandTotals.netResult)} ` +
            `(${grandTotals.netResult < 0 ? 'á€’á€­á€¯á€„á€ºá€¡á€›á€¾á€¯á€¶á€¸' : 'á€’á€­á€¯á€„á€ºá€¡á€™á€¼á€á€º'})`
        );

        // 6. Send message (split if too long)
        const fullMessage = messages.join('\n');
        if (fullMessage.length > 4000) {
            const half = Math.floor(messages.length / 2);
            await ctx.editMessageText(messages.slice(0, half).join('\n'));
            await ctx.telegram.sendMessage(
                ctx.chat.id,
                messages.slice(half).join('\n')
            );
        } else {
            await ctx.editMessageText(fullMessage);
        }

    } catch (e) {
        console.error(`Error in dateallView: ${e.message}`);
        await ctx.editMessageText("âŒ á€á€½á€€á€ºá€á€»á€€á€ºá€™á€¾á€¯á€¡á€™á€¾á€¬á€¸á€–á€¼á€…á€ºá€”á€±á€•á€«á€á€Šá€º");
    }
});

// Change working date command
async function changeWorkingDate(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
        
        // Show calendar with AM/PM selection
        const keyboard = [
            [Markup.button.callback("ğŸ—“ á€œá€€á€ºá€›á€¾á€­á€œá€¡á€á€½á€€á€º á€•á€¼á€€á€¹á€á€’á€­á€”á€º", "cdate_calendar")],
            [Markup.button.callback("â° AM á€›á€½á€±á€¸á€›á€”á€º", "cdate_am")],
            [Markup.button.callback("ğŸŒ™ PM á€›á€½á€±á€¸á€›á€”á€º", "cdate_pm")],
            [Markup.button.callback("ğŸ“† á€šá€”á€±á€·á€–á€½á€„á€·á€ºá€›á€”á€º", "cdate_open")]
        ];
        
        await ctx.reply(
            "ğŸ‘‰ á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«\n" +
            "â€¢ á€•á€¼á€€á€¹á€á€’á€­á€”á€ºá€–á€¼á€„á€·á€ºá€›á€½á€±á€¸á€›á€”á€º: ğŸ—“ á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«\n" +
            "â€¢ AM á€á€­á€¯á€·á€•á€¼á€±á€¬á€„á€ºá€¸á€›á€”á€º: â° á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«\n" +
            "â€¢ PM á€á€­á€¯á€·á€•á€¼á€±á€¬á€„á€ºá€¸á€›á€”á€º: ğŸŒ™ á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«\n" +
            "â€¢ á€šá€”á€±á€·á€á€­á€¯á€·á€•á€¼á€”á€ºá€›á€”á€º: ğŸ“† á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«",
            Markup.inlineKeyboard(keyboard)
        );
    } catch (e) {
        console.error(`Error in changeWorkingDate: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

// Calendar handlers
bot.action("cdate_calendar", async (ctx) => {
    try {
        const now = moment().tz(MYANMAR_TIMEZONE);
        const year = now.year();
        const month = now.month() + 1; // moment months are 0-11
        
        // Create calendar header
        const monthNames = [
            "á€‡á€”á€ºá€”á€á€«á€›á€®", "á€–á€±á€–á€±á€¬á€ºá€á€«á€›á€®", "á€™á€á€º", "á€§á€•á€¼á€®", "á€™á€±", "á€‡á€½á€”á€º",
            "á€‡á€°á€œá€­á€¯á€„á€º", "á€©á€‚á€¯á€á€º", "á€…á€€á€ºá€á€„á€ºá€˜á€¬", "á€¡á€±á€¬á€€á€ºá€á€­á€¯á€˜á€¬", "á€”á€­á€¯á€á€„á€ºá€˜á€¬", "á€’á€®á€‡á€„á€ºá€˜á€¬"
        ];
        const calHeader = `${monthNames[month - 1]} ${year}`;
        const days = ["á€á€”á€„á€ºá€¹á€œá€¬", "á€¡á€„á€ºá€¹á€‚á€«", "á€—á€¯á€’á€¹á€“á€Ÿá€°á€¸", "á€€á€¼á€¬á€á€•á€á€±á€¸", "á€á€±á€¬á€€á€¼á€¬", "á€…á€”á€±", "á€á€”á€„á€ºá€¹á€‚á€”á€½á€±"];
        
        // Generate calendar days
        const firstDay = moment(`${year}-${month}-01`, 'YYYY-MM-DD').tz(MYANMAR_TIMEZONE);
        const daysInMonth = firstDay.daysInMonth();
        const firstDayOfWeek = firstDay.day(); // 0-6 (Sunday-Saturday)
        
        // Adjust for Myanmar week start (Monday)
        const myanmarFirstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
        
        const weeks = [];
        let week = [];
        
        // Add empty cells for days before the first day of the month
        for (let i = 0; i < myanmarFirstDayOfWeek; i++) {
            week.push(Markup.button.callback(" ", "ignore"));
        }
        
        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
            week.push(Markup.button.callback(day.toString(), `cdate_day:${dateStr}`));
            
            if (week.length === 7) {
                weeks.push(week);
                week = [];
            }
        }
        
        // Add remaining days of the last week
        if (week.length > 0) {
            while (week.length < 7) {
                week.push(Markup.button.callback(" ", "ignore"));
            }
            weeks.push(week);
        }
        
        // Build calendar keyboard
        const keyboard = [];
        keyboard.push([Markup.button.callback(calHeader, "ignore")]);
        keyboard.push(days.map(day => Markup.button.callback(day, "ignore")));
        keyboard.push(...weeks);
        
        // Add navigation and back buttons
        keyboard.push([
            Markup.button.callback("â¬…ï¸ á€šá€á€„á€º", "cdate_prev_month"),
            Markup.button.callback("â¡ï¸ á€”á€±á€¬á€€á€º", "cdate_next_month")
        ]);
        keyboard.push([Markup.button.callback("ğŸ”™ á€”á€±á€¬á€€á€ºá€á€­á€¯á€·", "cdate_back")]);
        
        await ctx.editMessageText("ğŸ—“ á€”á€±á€·á€›á€€á€ºá€›á€½á€±á€¸á€›á€”á€º á€•á€¼á€€á€¹á€á€’á€­á€”á€º", Markup.inlineKeyboard(keyboard));
        
    } catch (e) {
        console.error(`Error in showCalendar: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action(/^cdate_day:(.+)$/, async (ctx) => {
    try {
        const dateStr = ctx.match[1];
        ctx.session = ctx.session || {};
        ctx.session.selectedDate = dateStr;
        
        // Ask for AM/PM selection
        const keyboard = [
            [Markup.button.callback("â° AM", "cdate_set_am")],
            [Markup.button.callback("ğŸŒ™ PM", "cdate_set_pm")],
            [Markup.button.callback("ğŸ”™ á€”á€±á€¬á€€á€ºá€á€­á€¯á€·", "cdate_back")]
        ];
        
        await ctx.editMessageText(
            `ğŸ‘‰ ${dateStr} á€¡á€á€½á€€á€º á€¡á€á€»á€­á€”á€ºá€•á€­á€¯á€„á€ºá€¸á€›á€½á€±á€¸á€•á€«`,
            Markup.inlineKeyboard(keyboard)
        );
        
    } catch (e) {
        console.error(`Error in handleDaySelection: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action(/^cdate_set_(am|pm)$/, async (ctx) => {
    try {
        const timeSegment = ctx.match[1].toUpperCase();
        const dateStr = ctx.session?.selectedDate;
        
        if (!dateStr) {
            await ctx.editMessageText("âŒ Error: Date not selected");
            return;
        }
            
        currentWorkingDate = `${dateStr} ${timeSegment}`;
        await ctx.editMessageText(`âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ ${currentWorkingDate} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®`);
        
    } catch (e) {
        console.error(`Error in setAmPm: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("cdate_am", async (ctx) => {
    try {
        if (currentWorkingDate) {
            const datePart = currentWorkingDate.split(' ')[0];
            currentWorkingDate = `${datePart} AM`;
            await ctx.editMessageText(`âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ ${currentWorkingDate} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®`);
        } else {
            await ctx.editMessageText("âŒ á€œá€€á€ºá€›á€¾á€­á€”á€±á€·á€›á€€á€º á€á€á€ºá€™á€¾á€á€ºá€‘á€¬á€¸á€á€¼á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«");
        }
    } catch (e) {
        console.error(`Error in setAm: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("cdate_pm", async (ctx) => {
    try {
        if (currentWorkingDate) {
            const datePart = currentWorkingDate.split(' ')[0];
            currentWorkingDate = `${datePart} PM`;
            await ctx.editMessageText(`âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ ${currentWorkingDate} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®`);
        } else {
            await ctx.editMessageText("âŒ á€œá€€á€ºá€›á€¾á€­á€”á€±á€·á€›á€€á€º á€á€á€ºá€™á€¾á€á€ºá€‘á€¬á€¸á€á€¼á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«");
        }
    } catch (e) {
        console.error(`Error in setPm: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("cdate_open", async (ctx) => {
    try {
        currentWorkingDate = getCurrentDateKey();
        await ctx.editMessageText(`âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ ${currentWorkingDate} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®`);
    } catch (e) {
        console.error(`Error in openCurrentDate: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action(/^cdate_(prev|next)_month$/, async (ctx) => {
    try {
        const direction = ctx.match[1];
        await ctx.answerCbQuery("â„¹ï¸ á€œá€™á€»á€¬á€¸á€œá€¾á€”á€ºá€€á€¼á€Šá€·á€ºá€á€¼á€„á€ºá€¸á€¡á€¬á€¸ á€”á€±á€¬á€€á€ºá€‘á€•á€ºá€—á€¬á€¸á€›á€¾á€„á€ºá€¸á€á€½á€„á€º á€‘á€Šá€·á€ºá€á€½á€„á€ºá€¸á€•á€«á€™á€Šá€º");
    } catch (e) {
        console.error(`Error in navigateMonth: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("cdate_back", async (ctx) => {
    try {
        await changeWorkingDate(ctx);
    } catch (e) {
        console.error(`Error in backToMain: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

// Delete date command
async function deleteDate(ctx) {
    try {
        if (ctx.from.id !== adminId) {
            await ctx.reply("âŒ Admin only command");
            return;
        }
            
        // Get all available dates
        const availableDates = getAvailableDates();
        
        if (availableDates.length === 0) {
            await ctx.reply("â„¹ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€…á€¬á€›á€„á€ºá€¸á€™á€¾ á€™á€›á€¾á€­á€á€±á€¸á€•á€«");
            return;
        }
            
        // Initialize selection dictionary
        const datedeleteSelections = {};
        availableDates.forEach(date => datedeleteSelections[date] = false);
        ctx.session = ctx.session || {};
        ctx.session.datedeleteSelections = datedeleteSelections;
        
        // Build message with checkboxes
        const msg = ["ğŸ—‘ á€–á€»á€€á€ºá€œá€­á€¯á€á€±á€¬á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"];
        const buttons = [];
        
        for (const date of availableDates) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = datedeleteSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? 'âœ…' : 'â¬œ'}`,
                    `datedelete_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("âœ… Delete Selected", "datedelete_confirm")]);
        
        await ctx.reply(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in deleteDate: ${e.message}`);
        await ctx.reply(`âŒ Error: ${e.message}`);
    }
}

bot.action(/^datedelete_toggle:(.+)$/, async (ctx) => {
    try {
        const dateKey = ctx.match[1];
        const datedeleteSelections = ctx.session?.datedeleteSelections || {};
        
        if (!datedeleteSelections[dateKey]) {
            await ctx.editMessageText("âŒ Error: Date not found");
            return;
        }
            
        // Toggle selection status
        datedeleteSelections[dateKey] = !datedeleteSelections[dateKey];
        ctx.session.datedeleteSelections = datedeleteSelections;
        
        // Rebuild the message with updated selections
        const msg = ["ğŸ—‘ á€–á€»á€€á€ºá€œá€­á€¯á€á€±á€¬á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"];
        const buttons = [];
        
        for (const date in datedeleteSelections) {
            const pnum = pnumberPerDate[date];
            const pnumStr = pnum !== undefined ? ` [P: ${pnum.toString().padStart(2, '0')}]` : "";
            
            const isSelected = datedeleteSelections[date];
            buttons.push([
                Markup.button.callback(
                    `${date}${pnumStr} ${isSelected ? 'âœ…' : 'â¬œ'}`,
                    `datedelete_toggle:${date}`
                )
            ]);
        }
        
        buttons.push([Markup.button.callback("âœ… Delete Selected", "datedelete_confirm")]);
        
        await ctx.editMessageText(msg.join('\n'), Markup.inlineKeyboard(buttons));
        
    } catch (e) {
        console.error(`Error in datedeleteToggle: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

bot.action("datedelete_confirm", async (ctx) => {
    try {
        const datedeleteSelections = ctx.session?.datedeleteSelections || {};
        
        // Get selected dates
        const selectedDates = Object.entries(datedeleteSelections)
            .filter(([_, selected]) => selected)
            .map(([date]) => date);
        
        if (selectedDates.length === 0) {
            await ctx.editMessageText("âš ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯á€™á€¾ á€™á€›á€½á€±á€¸á€á€»á€šá€ºá€‘á€¬á€¸á€•á€«");
            return;
        }
            
        // Delete data for selected dates
        for (const dateKey of selectedDates) {
            // Remove from user_data
            for (const user in userData) {
                if (userData[user][dateKey]) {
                    delete userData[user][dateKey];
                }
                // Remove user if no dates left
                if (Object.keys(userData[user]).length === 0) {
                    delete userData[user];
                }
            }
            
            // Remove from ledger
            if (ledger[dateKey]) {
                delete ledger[dateKey];
            }
            
            // Remove from break_limits
            if (breakLimits[dateKey]) {
                delete breakLimits[dateKey];
            }
            
            // Remove from pnumber_per_date
            if (pnumberPerDate[dateKey]) {
                delete pnumberPerDate[dateKey];
            }
            
            // Remove from date_control
            if (dateControl[dateKey]) {
                delete dateControl[dateKey];
            }
            
            // Remove from overbuy_list
            if (overbuyList[dateKey]) {
                delete overbuyList[dateKey];
            }
            
            // Remove from overbuy_selections
            if (overbuySelections[dateKey]) {
                delete overbuySelections[dateKey];
            }
        }
        
        // Clear current working date if it was deleted
        if (selectedDates.includes(currentWorkingDate)) {
            currentWorkingDate = null;
        }
        
        await ctx.editMessageText(`âœ… á€¡á€±á€¬á€€á€ºá€•á€«á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸ á€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®:\n${selectedDates.join(', ')}`);
        
    } catch (e) {
        console.error(`Error in datedeleteConfirm: ${e.message}`);
        await ctx.editMessageText("âŒ Error occurred");
    }
});

// Ignore callback
bot.action("ignore", async (ctx) => {
    await ctx.answerCbQuery();
});

// Start the bot
bot.launch().then(() => {
    console.log("ğŸš€ Bot is starting...");
});

// Enable graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
