á€¡á€á€¯boy.pyá€›á€²á€·á€¡á€á€»á€€á€ºá€¡á€œá€€á€ºá€™á€»á€¬á€¸ á€…á€”á€…á€ºá€™á€»á€¬á€¸ á€¡á€á€­á€¯á€„á€ºá€¸
á€œá€¯á€•á€ºá€†á€±á€¬á€„á€ºá€”á€­á€¯á€„á€ºá€›á€™á€šá€º á€¡á€€á€¯á€”á€ºá€œá€¯á€¶á€¸á€á€á€°á€¡á€±á€¬á€„á€º worker.jsá€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€•á€®á€¸ á€¡á€…á€¡á€†á€¯á€¶á€¸ á€¡á€•á€¼á€Šá€·á€ºá€¡á€…á€¯á€¶á€á€…á€ºá€†á€€á€ºá€á€Šá€ºá€¸á€›á€±á€¸á€•á€±á€¸á€•á€«
bot py
import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters
)
from datetime import datetime, time, timedelta
from tabulate import tabulate
import pytz
import re
import calendar

# Environment variable
TOKEN = os.getenv("BOT_TOKEN")

# Logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Timezone setup
MYANMAR_TIMEZONE = pytz.timezone('Asia/Yangon')

# Globals
admin_id = None
user_data = {}  # {username: {date_key: [(num, amt)]}}
ledger = {}     # {date_key: {number: total_amount}}
break_limits = {}  # {date_key: limit}
pnumber_per_date = {}  # {date_key: power_number}
date_control = {}  # {date_key: True/False}
overbuy_list = {}  # {date_key: {username: {num: amount}}}
message_store = {}  # {(user_id, message_id): (sent_message_id, bets, total_amount, date_key)}
overbuy_selections = {}  # {date_key: {username: {num: amount}}}
current_working_date = None  # For admin date selection

# Com and Za data
com_data = {}
za_data = {}

def reverse_number(n):
    s = str(n).zfill(2)
    return int(s[::-1])

def get_time_segment():
    now = datetime.now(MYANMAR_TIMEZONE).time()
    return "AM" if now < time(12, 0) else "PM"

def get_current_date_key():
    now = datetime.now(MYANMAR_TIMEZONE)
    return f"{now.strftime('%d/%m/%Y')} {get_time_segment()}"

def get_available_dates():
    dates = set()
    # Get dates from user data
    for user_data_dict in user_data.values():
        dates.update(user_data_dict.keys())
    # Get dates from ledger
    dates.update(ledger.keys())
    # Get dates from break limits
    dates.update(break_limits.keys())
    # Get dates from pnumber
    dates.update(pnumber_per_date.keys())
    return sorted(dates, reverse=True)

async def show_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = []
    if update.effective_user.id == admin_id:
        keyboard = [
            ["á€¡á€›á€±á€¬á€„á€ºá€¸á€–á€½á€„á€·á€ºá€›á€”á€º", "á€¡á€›á€±á€¬á€„á€ºá€¸á€•á€­á€á€ºá€›á€”á€º"],
            ["á€œá€Šá€ºá€á€»á€¬", "á€˜á€›á€­á€á€ºá€á€á€ºá€™á€¾á€á€ºá€›á€”á€º"],
            ["á€œá€»á€¾á€¶á€‚á€á€”á€ºá€¸á€™á€»á€¬á€¸á€á€šá€ºá€›á€”á€º", "á€•á€±á€«á€€á€ºá€á€®á€¸á€‘á€Šá€·á€ºá€›á€”á€º"],
            ["á€€á€±á€¬á€ºá€”á€¾á€„á€·á€ºá€¡á€† á€á€á€ºá€™á€¾á€á€ºá€›á€”á€º", "á€œá€€á€ºá€›á€¾á€­á€¡á€á€»á€­á€”á€ºá€™á€¾á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸"],
            ["á€‚á€á€”á€ºá€¸á€”á€¾á€„á€·á€ºá€„á€½á€±á€•á€±á€«á€„á€ºá€¸", "á€€á€±á€¬á€ºá€™á€›á€¾á€„á€ºá€™á€»á€¬á€¸"],
            ["á€›á€€á€ºá€á€»á€­á€”á€ºá€¸á€›á€”á€º", "á€á€…á€ºá€šá€±á€¬á€€á€ºá€á€¼á€„á€ºá€¸á€…á€¬á€›á€„á€ºá€¸"],
            ["á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€…á€¬á€›á€„á€ºá€¸á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸"],
            ["á€›á€€á€ºá€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€›á€”á€º", "á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€–á€»á€€á€ºá€›á€”á€º"]
        ]
    else:
        keyboard = [
            ["á€á€…á€ºá€šá€±á€¬á€€á€ºá€á€¼á€„á€ºá€¸á€…á€¬á€›á€„á€ºá€¸"]
        ]
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("á€™á€®á€”á€°á€¸á€€á€­á€¯á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«", reply_markup=reply_markup)

async def handle_menu_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    command_map = {
        "á€¡á€›á€±á€¬á€„á€ºá€¸á€–á€½á€„á€·á€ºá€›á€”á€º": "/dateopen",
        "á€¡á€›á€±á€¬á€„á€ºá€¸á€•á€­á€á€ºá€›á€”á€º": "/dateclose",
        "á€œá€Šá€ºá€á€»á€¬": "/ledger",
        "á€˜á€›á€­á€á€ºá€á€á€ºá€™á€¾á€á€ºá€›á€”á€º": "/break",
        "á€œá€»á€¾á€¶á€‚á€á€”á€ºá€¸á€™á€»á€¬á€¸á€á€šá€ºá€›á€”á€º": "/overbuy",
        "á€•á€±á€«á€€á€ºá€á€®á€¸á€‘á€Šá€·á€ºá€›á€”á€º": "/pnumber",
        "á€€á€±á€¬á€ºá€”á€¾á€„á€·á€ºá€¡á€† á€á€á€ºá€™á€¾á€á€ºá€›á€”á€º": "/comandza",
        "á€œá€€á€ºá€›á€¾á€­á€¡á€á€»á€­á€”á€ºá€™á€¾á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸": "/total",
        "á€‚á€á€”á€ºá€¸á€”á€¾á€„á€·á€ºá€„á€½á€±á€•á€±á€«á€„á€ºá€¸": "/tsent",
        "á€€á€±á€¬á€ºá€™á€›á€¾á€„á€ºá€™á€»á€¬á€¸": "/alldata",
        "á€›á€€á€ºá€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€›á€”á€º": "/reset",
        "á€á€…á€ºá€šá€±á€¬á€€á€ºá€á€¼á€„á€ºá€¸á€…á€¬á€›á€„á€ºá€¸": "/posthis",
        "á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€…á€¬á€›á€„á€ºá€¸á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸": "/dateall",
        "á€›á€€á€ºá€á€»á€­á€”á€ºá€¸á€›á€”á€º": "/Cdate",
        "á€›á€€á€ºá€¡á€œá€­á€¯á€€á€ºá€–á€»á€€á€ºá€›á€”á€º": "/Ddate"
    }
    
    if text in command_map:
        command = command_map[text]
        # Call the appropriate handler based on the command
        if command == "/dateopen":
            await dateopen(update, context)
        elif command == "/dateclose":
            await dateclose(update, context)
        elif command == "/ledger":
            await ledger_summary(update, context)
        elif command == "/break":
            await break_command(update, context)
        elif command == "/overbuy":
            await overbuy(update, context)
        elif command == "/pnumber":
            await pnumber(update, context)
        elif command == "/comandza":
            await comandza(update, context)
        elif command == "/total":
            await total(update, context)
        elif command == "/tsent":
            await tsent(update, context)
        elif command == "/alldata":
            await alldata(update, context)
        elif command == "/reset":
            await reset_data(update, context)
        elif command == "/posthis":
            await posthis(update, context)
        elif command == "/dateall":
            await dateall(update, context)
        elif command == "/Cdate":
            await change_working_date(update, context)
        elif command == "/Ddate":
            await delete_date(update, context)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, current_working_date
    admin_id = update.effective_user.id
    current_working_date = get_current_date_key()
    logger.info(f"Admin set to: {admin_id}")
    await update.message.reply_text("ğŸ¤– Bot started. Admin privileges granted!")
    await show_menu(update, context)

async def dateopen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    if update.effective_user.id != admin_id:
        await update.message.reply_text("âŒ Admin only command")
        return
        
    key = get_current_date_key()
    date_control[key] = True
    logger.info(f"Ledger opened for {key}")
    await update.message.reply_text(f"âœ… {key} á€…á€¬á€›á€„á€ºá€¸á€–á€½á€„á€·á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")

async def dateclose(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    if update.effective_user.id != admin_id:
        await update.message.reply_text("âŒ Admin only command")
        return
        
    key = get_current_date_key()
    date_control[key] = False
    logger.info(f"Ledger closed for {key}")
    await update.message.reply_text(f"âœ… {key} á€…á€¬á€›á€„á€ºá€¸á€•á€­á€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user = update.effective_user
        text = update.message.text
        
        if not user or not user.username:
            await update.message.reply_text("âŒ á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á Telegram username á€á€á€ºá€™á€¾á€á€ºá€•á€«")
            return

        key = get_current_date_key()
        if not date_control.get(key, False):
            await update.message.reply_text("âŒ á€…á€¬á€›á€„á€ºá€¸á€•á€­á€á€ºá€‘á€¬á€¸á€•á€«á€á€Šá€º")
            return

        if not text:
            await update.message.reply_text("âš ï¸ á€™á€€á€ºá€†á€±á€·á€‚á€»á€ºá€™á€›á€¾á€­á€•á€«")
            return

        # Process the message line by line
        lines = text.split('\n')
        all_bets = []
        total_amount = 0

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # Check for wheel cases first
            if 'á€¡á€á€½á€±' in line or 'á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±' in line:
                # Extract base numbers and amount
                if 'á€¡á€á€½á€±' in line:
                    parts = line.split('á€¡á€á€½á€±')
                    base_part = parts[0]
                    amount_part = parts[1]
                else:
                    parts = line.split('á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±')
                    base_part = parts[0]
                    amount_part = parts[1]
                
                # Clean base numbers (remove all non-digits)
                base_numbers = ''.join([c for c in base_part if c.isdigit()])
                
                # Clean amount (remove all non-digits)
                amount = int(''.join([c for c in amount_part if c.isdigit()]))
                
                # Generate all possible pairs
                pairs = []
                for i in range(len(base_numbers)):
                    for j in range(len(base_numbers)):
                        if i != j:
                            num = int(base_numbers[i] + base_numbers[j])
                            if num not in pairs:
                                pairs.append(num)
                
                # If á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±, add doubles
                if 'á€¡á€•á€°á€¸á€•á€«á€¡á€á€½á€±' in line:
                    for d in base_numbers:
                        double = int(d + d)
                        if double not in pairs:
                            pairs.append(double)
                
                # Add all bets
                for num in pairs:
                    all_bets.append(f"{num:02d}-{amount}")
                    total_amount += amount
                continue

            # Check for special cases
            special_cases = {
                "á€¡á€•á€°á€¸": [0, 11, 22, 33, 44, 55, 66, 77, 88, 99],
                "á€•á€«á€á€«": [5, 16, 27, 38, 49, 50, 61, 72, 83, 94],
                "á€”á€€á€¹á€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€€á€ºá€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€ºá€": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€ºá€á€€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€€á€ºá€á€€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€ºá€á€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€€á€ºá€á€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€”á€á€•á€º": [7, 18, 24, 35, 42, 53, 69, 70, 81, 96],
                "á€Šá€®á€€á€­á€¯": [1, 12, 23, 34, 45, 56, 67, 78, 89, 90],
                "á€€á€­á€¯á€Šá€®": [9, 10, 21, 32, 43, 54, 65, 76, 87, 98],
            }

            dynamic_types = ["á€‘á€­á€•á€º", "á€•á€­á€á€º", "á€˜á€›á€­á€á€º", "á€¡á€•á€«"]
            
            # Check for special cases with flexible formatting
            found_special = False
            for case_name, case_numbers in special_cases.items():
                # Check if line starts with any variation of the case name
                case_variations = [case_name]
                if case_name == "á€”á€€á€¹á€":
                    case_variations.extend(["á€”á€", "á€”á€€á€ºá€", "á€”á€á€ºá€", "á€”á€á€€á€º", "á€”á€á€ºá€á€€á€º", "á€”á€€á€ºá€á€€á€º", "á€”á€á€ºá€á€á€º", "á€”á€€á€ºá€á€á€º", "á€”á€á€á€º", "á€”á€á€•á€º"])
                
                for variation in case_variations:
                    if line.startswith(variation):
                        # Extract amount - allow any separator or none
                        amount_str = line[len(variation):].strip()
                        # Remove all non-digit characters
                        amount_str = ''.join([c for c in amount_str if c.isdigit()])
                        
                        if amount_str and int(amount_str) >= 100:
                            amt = int(amount_str)
                            for num in case_numbers:
                                all_bets.append(f"{num:02d}-{amt}")
                                total_amount += amt
                            found_special = True
                            break
                    if found_special:
                        break
                if found_special:
                    break
            
            if found_special:
                continue

            # Check for dynamic types with flexible formatting
            for dtype in dynamic_types:
                if dtype in line:
                    # Extract all numbers from the line
                    numbers = []
                    amount = 0
                    
                    # Find all number parts
                    parts = re.findall(r'\d+', line)
                    if parts:
                        # The last number is the amount
                        amount = int(parts[-1]) if int(parts[-1]) >= 100 else 0
                        # Other numbers are the digits
                        digits = [int(p) for p in parts[:-1] if len(p) == 1 and p.isdigit()]
                    
                    if amount >= 100 and digits:
                        numbers = []
                        if dtype == "á€‘á€­á€•á€º":
                            for d in digits:
                                numbers.extend([d * 10 + j for j in range(10)])
                        elif dtype == "á€•á€­á€á€º":
                            for d in digits:
                                numbers.extend([j * 10 + d for j in range(10)])
                        elif dtype == "á€˜á€›á€­á€á€º":
                            for d in digits:
                                numbers.extend([n for n in range(100) if (n//10 + n%10) % 10 == d])
                        elif dtype == "á€¡á€•á€«":
                            for d in digits:
                                tens = [d * 10 + j for j in range(10)]
                                units = [j * 10 + d for j in range(10)]
                                numbers.extend(list(set(tens + units)))
                        
                        for num in numbers:
                            all_bets.append(f"{num:02d}-{amount}")
                            total_amount += amount
                        found_special = True
                        break
            
            if found_special:
                continue

            # Process regular number-amount pairs with r/R (flexible formatting)
            if 'r' in line.lower():
                # Split into parts before and after r/R
                r_pos = line.lower().find('r')
                before_r = line[:r_pos]
                after_r = line[r_pos+1:]
                
                # Extract numbers before r
                nums_before = re.findall(r'\d+', before_r)
                nums_before = [int(n) for n in nums_before if 0 <= int(n) <= 99]
                
                # Extract amounts after r
                amounts = re.findall(r'\d+', after_r)
                amounts = [int(a) for a in amounts if int(a) >= 100]
                
                if nums_before and amounts:
                    if len(amounts) == 1:
                        # Single amount: apply to both base and reverse
                        for num in nums_before:
                            all_bets.append(f"{num:02d}-{amounts[0]}")
                            all_bets.append(f"{reverse_number(num):02d}-{amounts[0]}")
                            total_amount += amounts[0] * 2
                    else:
                        # Two amounts: first for base, second for reverse
                        for num in nums_before:
                            all_bets.append(f"{num:02d}-{amounts[0]}")
                            all_bets.append(f"{reverse_number(num):02d}-{amounts[1]}")
                            total_amount += amounts[0] + amounts[1]
                    continue

            # Process regular number-amount pairs without r/R (flexible formatting)
            numbers = []
            amount = 0
            
            # Find all numbers in the line
            all_numbers = re.findall(r'\d+', line)
            if all_numbers:
                # The last number is the amount if it's >= 100
                if int(all_numbers[-1]) >= 100:
                    amount = int(all_numbers[-1])
                    # Other numbers are the bet numbers
                    numbers = [int(n) for n in all_numbers[:-1] if 0 <= int(n) <= 99]
                else:
                    # Maybe the line is just numbers separated by something
                    # Try to find pairs where second number is >= 100
                    for i in range(len(all_numbers)-1):
                        if 0 <= int(all_numbers[i]) <= 99 and int(all_numbers[i+1]) >= 100:
                            numbers.append(int(all_numbers[i]))
                            amount = int(all_numbers[i+1])
                            break
            
            if amount >= 100 and numbers:
                for num in numbers:
                    all_bets.append(f"{num:02d}-{amount}")
                    total_amount += amount

        if not all_bets:
            await update.message.reply_text("âš ï¸ á€¡á€á€»á€€á€ºá€¡á€œá€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯á€…á€…á€ºá€†á€±á€¸á€•á€«\ná€¥á€•á€™á€¬: 12-1000,12/34-1000 \n 12r1000,12r1000-500")
            return

        # Update data stores
        if user.username not in user_data:
            user_data[user.username] = {}
        if key not in user_data[user.username]:
            user_data[user.username][key] = []

        if key not in ledger:
            ledger[key] = {}

        for bet in all_bets:
            num, amt = bet.split('-')
            num = int(num)
            amt = int(amt)
            
            # Update ledger
            if num not in ledger[key]:
                ledger[key][num] = 0
            ledger[key][num] += amt
            
            # Update user data
            user_data[user.username][key].append((num, amt))

            # Send confirmation with delete button
        response = "\n".join(all_bets) + f"\ná€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸ {total_amount} á€€á€»á€•á€º"
        keyboard = [[InlineKeyboardButton("ğŸ—‘ Delete", callback_data=f"delete:{user.id}:{update.message.message_id}:{key}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        sent_message = await update.message.reply_text(response, reply_markup=reply_markup)
        message_store[(user.id, update.message.message_id)] = (sent_message.message_id, all_bets, total_amount, key)
            
    except Exception as e:
        logger.error(f"Error in handle_message: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def delete_bet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, user_id_str, message_id_str, date_key = query.data.split(':')
        user_id = int(user_id_str)
        message_id = int(message_id_str)
        
        # Only admin can interact with delete button
        if query.from_user.id != admin_id:
            await query.edit_message_text("âŒ Admin only action")
            return
            
        keyboard = [
            [InlineKeyboardButton("âœ… OK", callback_data=f"confirm_delete:{user_id}:{message_id}:{date_key}")],
            [InlineKeyboardButton("âŒ Cancel", callback_data=f"cancel_delete:{user_id}:{message_id}:{date_key}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("âš ï¸ á€á€±á€á€»á€¬á€œá€¬á€¸? á€’á€®á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€€á€­á€¯á€–á€»á€€á€ºá€™á€¾á€¬á€œá€¬á€¸?", reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in delete_bet: {str(e)}")
        await query.edit_message_text("âŒ Error occurred while processing deletion")

async def confirm_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, user_id_str, message_id_str, date_key = query.data.split(':')
        user_id = int(user_id_str)
        message_id = int(message_id_str)
        
        if (user_id, message_id) not in message_store:
            await query.edit_message_text("âŒ á€’á€±á€á€¬á€™á€á€½á€±á€·á€•á€«")
            return
            
        sent_message_id, bets, total_amount, _ = message_store[(user_id, message_id)]
        
        username = None
        for uname, data in user_data.items():
            if date_key in data:
                for bet in data[date_key]:
                    num, amt = bet
                    if f"{num:02d}-{amt}" in bets:
                        username = uname
                        break
                if username:
                    break
        
        if not username:
            await query.edit_message_text("âŒ User á€™á€á€½á€±á€·á€•á€«")
            return
        
        for bet in bets:
            num, amt = bet.split('-')
            num = int(num)
            amt = int(amt)
            
            if date_key in ledger and num in ledger[date_key]:
                ledger[date_key][num] -= amt
                if ledger[date_key][num] <= 0:
                    del ledger[date_key][num]
                # Remove date from ledger if empty
                if not ledger[date_key]:
                    del ledger[date_key]
            
            if username in user_data and date_key in user_data[username]:
                user_data[username][date_key] = [
                    (n, a) for n, a in user_data[username][date_key] 
                    if not (n == num and a == amt)
                ]
                
                if not user_data[username][date_key]:
                    del user_data[username][date_key]
                    if not user_data[username]:
                        del user_data[username]
        
        del message_store[(user_id, message_id)]
        
        await query.edit_message_text("âœ… á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
        
    except Exception as e:
        logger.error(f"Error in confirm_delete: {str(e)}")
        await query.edit_message_text("âŒ Error occurred while deleting bet")

async def cancel_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, user_id_str, message_id_str, date_key = query.data.split(':')
        user_id = int(user_id_str)
        message_id = int(message_id_str)
        
        if (user_id, message_id) in message_store:
            sent_message_id, bets, total_amount, _ = message_store[(user_id, message_id)]
            response = "\n".join(bets) + f"\ná€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸ {total_amount} á€€á€»á€•á€º"
            keyboard = [[InlineKeyboardButton("ğŸ—‘ Delete", callback_data=f"delete:{user_id}:{message_id}:{date_key}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(response, reply_markup=reply_markup)
        else:
            await query.edit_message_text("â„¹ï¸ á€–á€»á€€á€ºá€á€¼á€„á€ºá€¸á€€á€­á€¯á€•á€šá€ºá€–á€»á€€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
            
    except Exception as e:
        logger.error(f"Error in cancel_delete: {str(e)}")
        await query.edit_message_text("âŒ Error occurred while canceling deletion")

async def ledger_summary(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Determine which date to show
        date_key = current_working_date if current_working_date else get_current_date_key()
        
        if date_key not in ledger:
            await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€œá€€á€ºá€›á€¾á€­á€á€½á€„á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€•á€«")
            return
            
        lines = [f"ğŸ“’ {date_key} á€œá€€á€ºá€€á€»á€”á€ºá€„á€½á€±á€…á€¬á€›á€„á€ºá€¸"]
        ledger_data = ledger[date_key]
        
        total_all_numbers = 0  # á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€„á€½á€±á€¡á€á€½á€€á€º
        
        for i in range(100):
            total = ledger_data.get(i, 0)
            if total > 0:
                if date_key in pnumber_per_date and i == pnumber_per_date[date_key]:
                    lines.append(f"ğŸ”´ {i:02d} â¤ {total} ğŸ”´")
                else:
                    lines.append(f"{i:02d} â¤ {total}")
                total_all_numbers += total  # á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€„á€½á€±á€á€½á€€á€ºá€›á€”á€º

        if len(lines) == 1:
            await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€œá€€á€ºá€›á€¾á€­á€á€½á€„á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€•á€«")
        else:
            if date_key in pnumber_per_date:
                pnum = pnumber_per_date[date_key]
                lines.append(f"\nğŸ”´ Power Number: {pnum:02d} â¤ {ledger_data.get(pnum, 0)}")
            
            # á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€„á€½á€±á€•á€¼á€›á€”á€º á€¡á€±á€¬á€€á€ºá€á€¼á€±á€á€½á€„á€º á€‘á€Šá€·á€ºá€•á€«
            lines.append(f"\nğŸ’° á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {total_all_numbers} á€€á€»á€•á€º")
            await update.message.reply_text("\n".join(lines))
    except Exception as e:
        logger.error(f"Error in ledger: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")
        
async def break_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, break_limits, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Determine which date to work on
        date_key = current_working_date if current_working_date else get_current_date_key()
            
        if not context.args:
            if date_key in break_limits:
                await update.message.reply_text(f"â„¹ï¸ Usage: /break [limit]\nâ„¹ï¸ á€œá€€á€ºá€›á€¾á€­á€á€½á€„á€º break limit: {break_limits[date_key]}")
            else:
                await update.message.reply_text(f"â„¹ï¸ Usage: /break [limit]\nâ„¹ï¸ {date_key} á€¡á€á€½á€€á€º break limit á€™á€á€á€ºá€™á€¾á€á€ºá€›á€á€±á€¸á€•á€«")
            return
            
        try:
            new_limit = int(context.args[0])
            break_limits[date_key] = new_limit
            await update.message.reply_text(f"âœ… {date_key} á€¡á€á€½á€€á€º Break limit á€€á€­á€¯ {new_limit} á€¡á€–á€¼á€…á€ºá€á€á€ºá€™á€¾á€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
            
            if date_key not in ledger:
                await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€á€±á€¸á€•á€«")
                return
                
            ledger_data = ledger[date_key]
            msg = [f"ğŸ“Œ {date_key} á€¡á€á€½á€€á€º Limit ({new_limit}) á€€á€»á€±á€¬á€ºá€‚á€á€”á€ºá€¸á€™á€»á€¬á€¸:"]
            found = False
            
            for num, amt in ledger_data.items():
                if amt > new_limit:
                    msg.append(f"{num:02d} â¤ {amt - new_limit}")
                    found = True
            
            if not found:
                await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€˜á€šá€ºá€‚á€á€”á€ºá€¸á€™á€¾ limit ({new_limit}) á€™á€€á€»á€±á€¬á€ºá€•á€«")
            else:
                await update.message.reply_text("\n".join(msg))
                
        except ValueError:
            await update.message.reply_text("âš ï¸ Limit amount á€‘á€Šá€·á€ºá€•á€« (á€¥á€•á€™á€¬: /break 5000)")
            
    except Exception as e:
        logger.error(f"Error in break: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def overbuy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, break_limits, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Determine which date to work on
        date_key = current_working_date if current_working_date else get_current_date_key()
            
        if not context.args:
            await update.message.reply_text("â„¹ï¸ á€€á€¬á€’á€­á€¯á€„á€ºá€¡á€™á€Šá€ºá€‘á€Šá€·á€ºá€•á€«")
            return
            
        if date_key not in break_limits:
            await update.message.reply_text(f"âš ï¸ {date_key} á€¡á€á€½á€€á€º á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á /break [limit] á€–á€¼á€„á€·á€º limit á€á€á€ºá€™á€¾á€á€ºá€•á€«")
            return
            
        if date_key not in ledger:
            await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€á€±á€¸á€•á€«")
            return
            
        username = context.args[0]
        context.user_data['overbuy_username'] = username
        context.user_data['overbuy_date'] = date_key
        
        ledger_data = ledger[date_key]
        break_limit_val = break_limits[date_key]
        over_numbers = {num: amt - break_limit_val for num, amt in ledger_data.items() if amt > break_limit_val}
        
        if not over_numbers:
            await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€˜á€šá€ºá€‚á€á€”á€ºá€¸á€™á€¾ limit ({break_limit_val}) á€™á€€á€»á€±á€¬á€ºá€•á€«")
            return
            
        if date_key not in overbuy_selections:
            overbuy_selections[date_key] = {}
        overbuy_selections[date_key][username] = over_numbers.copy()
        
        msg = [f"{username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: {date_key}, Limit: {break_limit_val}):"]
        buttons = []
        for num, amt in over_numbers.items():
            buttons.append([InlineKeyboardButton(f"{num:02d} â¤ {amt} {'âœ…' if num in overbuy_selections[date_key][username] else 'â¬œ'}", 
                          callback_data=f"overbuy_select:{num}")])
        
        buttons.append([
            InlineKeyboardButton("Select All", callback_data="overbuy_select_all"),
            InlineKeyboardButton("Unselect All", callback_data="overbuy_unselect_all")
        ])
        buttons.append([InlineKeyboardButton("OK", callback_data="overbuy_confirm")])
        
        reply_markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in overbuy: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def overbuy_select(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, num_str = query.data.split(':')
        num = int(num_str)
        username = context.user_data.get('overbuy_username')
        date_key = context.user_data.get('overbuy_date')
        
        if not username or not date_key:
            await query.edit_message_text("âŒ Error: User or date not found")
            return
            
        if date_key not in overbuy_selections or username not in overbuy_selections[date_key]:
            await query.edit_message_text("âŒ Error: Selection data not found")
            return
            
        if num in overbuy_selections[date_key][username]:
            del overbuy_selections[date_key][username][num]
        else:
            break_limit_val = break_limits[date_key]
            overbuy_selections[date_key][username][num] = ledger[date_key][num] - break_limit_val
            
        msg = [f"{username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: {date_key}):"]
        buttons = []
        for n, amt in overbuy_selections[date_key][username].items():
            buttons.append([InlineKeyboardButton(f"{n:02d} â¤ {amt} {'âœ…' if n in overbuy_selections[date_key][username] else 'â¬œ'}", 
                          callback_data=f"overbuy_select:{n}")])
        
        buttons.append([
            InlineKeyboardButton("Select All", callback_data="overbuy_select_all"),
            InlineKeyboardButton("Unselect All", callback_data="overbuy_unselect_all")
        ])
        buttons.append([InlineKeyboardButton("OK", callback_data="overbuy_confirm")])
        
        reply_markup = InlineKeyboardMarkup(buttons)
        await query.edit_message_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in overbuy_select: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def overbuy_select_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        username = context.user_data.get('overbuy_username')
        date_key = context.user_data.get('overbuy_date')
        
        if not username or not date_key:
            await query.edit_message_text("âŒ Error: User or date not found")
            return
            
        if date_key not in overbuy_selections:
            overbuy_selections[date_key] = {}
            
        break_limit_val = break_limits[date_key]
        ledger_data = ledger[date_key]
        overbuy_selections[date_key][username] = {
            num: amt - break_limit_val 
            for num, amt in ledger_data.items() 
            if amt > break_limit_val
        }
        
        msg = [f"{username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: {date_key}):"]
        buttons = []
        for num, amt in overbuy_selections[date_key][username].items():
            buttons.append([InlineKeyboardButton(f"{num:02d} â¤ {amt} âœ…", 
                          callback_data=f"overbuy_select:{num}")])
        
        buttons.append([
            InlineKeyboardButton("Select All", callback_data="overbuy_select_all"),
            InlineKeyboardButton("Unselect All", callback_data="overbuy_unselect_all")
        ])
        buttons.append([InlineKeyboardButton("OK", callback_data="overbuy_confirm")])
        
        reply_markup = InlineKeyboardMarkup(buttons)
        await query.edit_message_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in overbuy_select_all: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def overbuy_unselect_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        username = context.user_data.get('overbuy_username')
        date_key = context.user_data.get('overbuy_date')
        
        if not username or not date_key:
            await query.edit_message_text("âŒ Error: User or date not found")
            return
            
        if date_key not in overbuy_selections:
            overbuy_selections[date_key] = {}
            
        overbuy_selections[date_key][username] = {}
        
        break_limit_val = break_limits[date_key]
        ledger_data = ledger[date_key]
        over_numbers = {num: amt - break_limit_val for num, amt in ledger_data.items() if amt > break_limit_val}
        
        msg = [f"{username} á€‘á€¶á€™á€¾á€¬á€á€„á€ºá€›á€”á€ºá€™á€»á€¬á€¸ (Date: {date_key}):"]
        buttons = []
        for num, amt in over_numbers.items():
            buttons.append([InlineKeyboardButton(f"{num:02d} â¤ {amt} â¬œ", 
                          callback_data=f"overbuy_select:{num}")])
        
        buttons.append([
            InlineKeyboardButton("Select All", callback_data="overbuy_select_all"),
            InlineKeyboardButton("Unselect All", callback_data="overbuy_unselect_all")
        ])
        buttons.append([InlineKeyboardButton("OK", callback_data="overbuy_confirm")])
        
        reply_markup = InlineKeyboardMarkup(buttons)
        await query.edit_message_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in overbuy_unselect_all: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def overbuy_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        username = context.user_data.get('overbuy_username')
        date_key = context.user_data.get('overbuy_date')
        
        if not username or not date_key:
            await query.edit_message_text("âŒ Error: User or date not found")
            return
            
        if date_key not in overbuy_selections or username not in overbuy_selections[date_key]:
            await query.edit_message_text("âŒ Error: Selection data not found")
            return
            
        selected_numbers = overbuy_selections[date_key][username]
        if not selected_numbers:
            await query.edit_message_text("âš ï¸ á€˜á€¬á€‚á€á€”á€ºá€¸á€™á€¾á€™á€›á€½á€±á€¸á€‘á€¬á€¸á€•á€«")
            return
            
        if username not in user_data:
            user_data[username] = {}
        if date_key not in user_data[username]:
            user_data[username][date_key] = []
            
        total_amount = 0
        bets = []
        for num, amt in selected_numbers.items():
            user_data[username][date_key].append((num, -amt))
            bets.append(f"{num:02d}-{amt}")
            total_amount += amt
            
            # Update ledger
            ledger[date_key][num] = ledger[date_key].get(num, 0) - amt
            if ledger[date_key][num] <= 0:
                del ledger[date_key][num]
        
        # Initialize overbuy_list for date if needed
        if date_key not in overbuy_list:
            overbuy_list[date_key] = {}
        overbuy_list[date_key][username] = selected_numbers.copy()
        
        response = f"{username} - {date_key}\n" + "\n".join(bets) + f"\ná€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸ {total_amount} á€€á€»á€•á€º"
        await query.edit_message_text(response)
        
    except Exception as e:
        logger.error(f"Error in overbuy_confirm: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def pnumber(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, pnumber_per_date, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Determine which date to work on
        date_key = current_working_date if current_working_date else get_current_date_key()
            
        if not context.args:
            if date_key in pnumber_per_date:
                await update.message.reply_text(f"â„¹ï¸ Usage: /pnumber [number]\nâ„¹ï¸ {date_key} á€¡á€á€½á€€á€º Power Number: {pnumber_per_date[date_key]:02d}")
            else:
                await update.message.reply_text(f"â„¹ï¸ Usage: /pnumber [number]\nâ„¹ï¸ {date_key} á€¡á€á€½á€€á€º Power Number á€™á€á€á€ºá€™á€¾á€á€ºá€›á€á€±á€¸á€•á€«")
            return
            
        try:
            num = int(context.args[0])
            if num < 0 or num > 99:
                await update.message.reply_text("âš ï¸ á€‚á€á€”á€ºá€¸á€€á€­á€¯ 0 á€”á€¾á€„á€·á€º 99 á€€á€¼á€¬á€¸á€‘á€Šá€·á€ºá€•á€«")
                return
                
            pnumber_per_date[date_key] = num
            await update.message.reply_text(f"âœ… {date_key} á€¡á€á€½á€€á€º Power Number á€€á€­á€¯ {num:02d} á€¡á€–á€¼á€…á€ºá€á€á€ºá€™á€¾á€á€ºá€•á€¼á€®á€¸")
            
            # Show report for this date
            msg = []
            total_power = 0
            
            for user, records in user_data.items():
                if date_key in records:
                    user_total = 0
                    for bet_num, amt in records[date_key]:
                        if bet_num == num:
                            user_total += amt
                    if user_total > 0:
                        msg.append(f"{user}: {num:02d} â¤ {user_total}")
                        total_power += user_total
            
            if msg:
                msg.append(f"\nğŸ”´ {date_key} á€¡á€á€½á€€á€º Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {total_power}")
                await update.message.reply_text("\n".join(msg))
            else:
                await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º {num:02d} á€¡á€á€½á€€á€º á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€›á€¾á€­á€•á€«")
                
        except ValueError:
            await update.message.reply_text("âš ï¸ á€‚á€á€”á€ºá€¸á€™á€¾á€”á€ºá€™á€¾á€”á€ºá€‘á€Šá€·á€ºá€•á€« (á€¥á€•á€™á€¬: /pnumber 15)")
            
    except Exception as e:
        logger.error(f"Error in pnumber: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def comandza(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        if not user_data:
            await update.message.reply_text("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­ user á€™á€›á€¾á€­á€•á€«")
            return
            
        users = list(user_data.keys())
        keyboard = [[InlineKeyboardButton(u, callback_data=f"comza:{u}")] for u in users]
        await update.message.reply_text("ğŸ‘‰ User á€€á€­á€¯á€›á€½á€±á€¸á€•á€«", reply_markup=InlineKeyboardMarkup(keyboard))
    except Exception as e:
        logger.error(f"Error in comandza: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def comza_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()
        context.user_data['selected_user'] = query.data.split(":")[1]
        await query.edit_message_text(f"ğŸ‘‰ {context.user_data['selected_user']} á€€á€­á€¯á€›á€½á€±á€¸á€‘á€¬á€¸á€á€Šá€ºá‹ 15/80 á€œá€­á€¯á€·á€‘á€Šá€·á€ºá€•á€«")
    except Exception as e:
        logger.error(f"Error in comza_input: {str(e)}")
        await query.edit_message_text(f"âŒ Error: {str(e)}")

async def comza_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user = context.user_data.get('selected_user')
        if not user:
            await handle_message(update, context)
            return
            
        text = update.message.text
        if text and '/' in text:
            try:
                parts = text.split('/')
                if len(parts) != 2:
                    raise ValueError
                
                com = int(parts[0])
                za = int(parts[1])
                
                if com < 0 or com > 100 or za < 0:
                    raise ValueError
                    
                com_data[user] = com
                za_data[user] = za
                del context.user_data['selected_user']
                await update.message.reply_text(f"âœ… Com {com}%, Za {za} á€™á€¾á€á€ºá€‘á€¬á€¸á€•á€¼á€®á€¸")
            except:
                await update.message.reply_text("âš ï¸ á€™á€¾á€”á€ºá€™á€¾á€”á€ºá€›á€±á€¸á€•á€« (á€¥á€•á€™á€¬: 15/80)")
        else:
            await update.message.reply_text("âš ï¸ á€–á€±á€¬á€ºá€™á€á€ºá€™á€¾á€¬á€¸á€”á€±á€•á€«á€á€Šá€ºá‹ 15/80 á€œá€­á€¯á€·á€‘á€Šá€·á€ºá€•á€«")
    except Exception as e:
        logger.error(f"Error in comza_text: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def total(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Determine which date to work on
        date_key = current_working_date if current_working_date else get_current_date_key()
            
        if date_key not in pnumber_per_date:
            await update.message.reply_text(f"âš ï¸ {date_key} á€¡á€á€½á€€á€º á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á /pnumber [number] á€–á€¼á€„á€·á€º Power Number á€á€á€ºá€™á€¾á€á€ºá€•á€«")
            return
            
        if not user_data:
            await update.message.reply_text("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
            return
            
        pnum = pnumber_per_date[date_key]
        msg = [f"ğŸ“Š {date_key} á€¡á€á€½á€€á€º á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º"]
        total_net = 0
        
        for user, records in user_data.items():
            if date_key in records:
                user_total_amt = 0
                user_pamt = 0
                
                for num, amt in records[date_key]:
                    user_total_amt += amt
                    if num == pnum:
                        user_pamt += amt
                
                com = com_data.get(user, 0)
                za = za_data.get(user, 0)
                
                commission_amt = (user_total_amt * com) // 100
                after_com = user_total_amt - commission_amt
                win_amt = user_pamt * za
                
                net = after_com - win_amt
                status = "á€’á€­á€¯á€„á€ºá€€á€•á€±á€¸á€›á€™á€Šá€º" if net < 0 else "á€’á€­á€¯á€„á€ºá€€á€›á€™á€Šá€º"
                
                user_report = (
                    f"ğŸ‘¤ {user}\n"
                    f"ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {user_total_amt}\n"
                    f"ğŸ“Š Com({com}%) â¤ {commission_amt}\n"
                    f"ğŸ’° Com á€•á€¼á€®á€¸: {after_com}\n"
                    f"ğŸ”¢ Power Number({pnum:02d}) â¤ {user_pamt}\n"
                    f"ğŸ¯ Za({za}) â¤ {win_amt}\n"
                    f"ğŸ“ˆ á€›á€œá€’á€º: {abs(net)} ({status})\n"
                    "-----------------"
                )
                msg.append(user_report)
                total_net += net

        if len(msg) > 1:
            msg.append(f"\nğŸ“Š á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º: {abs(total_net)} ({'á€’á€­á€¯á€„á€ºá€¡á€›á€¾á€¯á€¶á€¸' if total_net < 0 else 'á€’á€­á€¯á€„á€ºá€¡á€™á€¼á€á€º'})")
            await update.message.reply_text("\n".join(msg))
        else:
            await update.message.reply_text(f"â„¹ï¸ {date_key} á€¡á€á€½á€€á€º á€’á€±á€á€¬á€™á€›á€¾á€­á€•á€«")
    except Exception as e:
        logger.error(f"Error in total: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def tsent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Determine which date to work on
        date_key = current_working_date if current_working_date else get_current_date_key()
            
        if not user_data:
            await update.message.reply_text("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­ user á€™á€›á€¾á€­á€•á€«")
            return
            
        for user in user_data:
            if date_key in user_data[user]:
                user_report = [f"ğŸ‘¤ {user} - {date_key}:"]
                total_amt = 0
                
                for num, amt in user_data[user][date_key]:
                    user_report.append(f"  - {num:02d} â¤ {amt}")
                    total_amt += amt
                
                user_report.append(f"ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {total_amt}")
                await update.message.reply_text("\n".join(user_report))
        
        await update.message.reply_text(f"âœ… {date_key} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€»á€¬á€¸á€¡á€¬á€¸á€œá€¯á€¶á€¸ á€•á€±á€¸á€•á€­á€¯á€·á€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
    except Exception as e:
        logger.error(f"Error in tsent: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def alldata(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        if not user_data:
            await update.message.reply_text("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
            return
            
        msg = ["ğŸ‘¥ á€™á€¾á€á€ºá€•á€¯á€¶á€á€„á€ºá€‘á€¬á€¸á€á€±á€¬ user á€™á€»á€¬á€¸:"]
        msg.extend([f"â€¢ {user}" for user in user_data.keys()])
        
        await update.message.reply_text("\n".join(msg))
    except Exception as e:
        logger.error(f"Error in alldata: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def reset_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id, user_data, ledger, za_data, com_data, date_control, overbuy_list, overbuy_selections, break_limits, pnumber_per_date, current_working_date
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        user_data = {}
        ledger = {}
        za_data = {}
        com_data = {}
        date_control = {}
        overbuy_list = {}
        overbuy_selections = {}
        break_limits = {}
        pnumber_per_date = {}
        current_working_date = get_current_date_key()
        
        await update.message.reply_text("âœ… á€’á€±á€á€¬á€™á€»á€¬á€¸á€¡á€¬á€¸á€œá€¯á€¶á€¸á€€á€­á€¯ á€•á€¼á€”á€ºá€œá€Šá€ºá€á€¯á€á€ºá€á€„á€ºá€•á€¼á€®á€¸ á€œá€€á€ºá€›á€¾á€­á€”á€±á€·á€á€­á€¯á€·á€•á€¼á€”á€ºá€œá€Šá€ºá€á€á€ºá€™á€¾á€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
    except Exception as e:
        logger.error(f"Error in reset_data: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def posthis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user = update.effective_user
        is_admin = user.id == admin_id
        
        if is_admin and not context.args:
            if not user_data:
                await update.message.reply_text("â„¹ï¸ á€œá€€á€ºá€›á€¾á€­ user á€™á€›á€¾á€­á€•á€«")
                return
                
            keyboard = [[InlineKeyboardButton(u, callback_data=f"posthis:{u}")] for u in user_data.keys()]
            await update.message.reply_text(
                "á€˜á€šá€º user á€›á€²á€·á€…á€¬á€›á€„á€ºá€¸á€€á€­á€¯á€€á€¼á€Šá€·á€ºá€™á€œá€²?",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return
        
        username = user.username if not is_admin else context.args[0] if context.args else None
        
        if not username:
            await update.message.reply_text("âŒ User á€™á€›á€¾á€­á€•á€«")
            return
            
        if username not in user_data:
            await update.message.reply_text(f"â„¹ï¸ {username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
            return
            
        # For non-admin, show current date only
        date_key = get_current_date_key() if not is_admin else None
        
        msg = [f"ğŸ“Š {username} á€›á€²á€·á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€¾á€á€ºá€á€™á€ºá€¸"]
        total_amount = 0
        pnumber_total = 0
        
        if is_admin:
            # Admin can see all dates
            for date_key in user_data[username]:
                pnum = pnumber_per_date.get(date_key, None)
                pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
                
                msg.append(f"\nğŸ“… {date_key}{pnum_str}:")
                for num, amt in user_data[username][date_key]:
                    if pnum is not None and num == pnum:
                        msg.append(f"ğŸ”´ {num:02d} â¤ {amt} ğŸ”´")
                        pnumber_total += amt
                    else:
                        msg.append(f"{num:02d} â¤ {amt}")
                    total_amount += amt
        else:
            # Non-admin only sees current date
            if date_key in user_data[username]:
                pnum = pnumber_per_date.get(date_key, None)
                pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
                
                msg.append(f"\nğŸ“… {date_key}{pnum_str}:")
                for num, amt in user_data[username][date_key]:
                    if pnum is not None and num == pnum:
                        msg.append(f"ğŸ”´ {num:02d} â¤ {amt} ğŸ”´")
                        pnumber_total += amt
                    else:
                        msg.append(f"{num:02d} â¤ {amt}")
                    total_amount += amt
        
        if len(msg) > 1:
            msg.append(f"\nğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {total_amount}")
            if pnumber_total > 0:
                msg.append(f"ğŸ”´ Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {pnumber_total}")
            await update.message.reply_text("\n".join(msg))
        else:
            await update.message.reply_text(f"â„¹ï¸ {username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
        
    except Exception as e:
        logger.error(f"Error in posthis: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def posthis_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, username = query.data.split(':')
        msg = [f"ğŸ“Š {username} á€›á€²á€·á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸á€™á€¾á€á€ºá€á€™á€ºá€¸"]
        total_amount = 0
        pnumber_total = 0
        
        if username in user_data:
            for date_key in user_data[username]:
                pnum = pnumber_per_date.get(date_key, None)
                pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
                
                msg.append(f"\nğŸ“… {date_key}{pnum_str}:")
                for num, amt in user_data[username][date_key]:
                    if pnum is not None and num == pnum:
                        msg.append(f"ğŸ”´ {num:02d} â¤ {amt} ğŸ”´")
                        pnumber_total += amt
                    else:
                        msg.append(f"{num:02d} â¤ {amt}")
                    total_amount += amt
            
            if len(msg) > 1:
                msg.append(f"\nğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {total_amount}")
                if pnumber_total > 0:
                    msg.append(f"ğŸ”´ Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {pnumber_total}")
                await query.edit_message_text("\n".join(msg))
            else:
                await query.edit_message_text(f"â„¹ï¸ {username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
        else:
            await query.edit_message_text(f"â„¹ï¸ {username} á€¡á€á€½á€€á€º á€…á€¬á€›á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
            
    except Exception as e:
        logger.error(f"Error in posthis_callback: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def dateall(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Get all unique dates from user_data
        all_dates = get_available_dates()
        
        if not all_dates:
            await update.message.reply_text("â„¹ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€…á€¬á€›á€„á€ºá€¸á€™á€¾ á€™á€›á€¾á€­á€á€±á€¸á€•á€«")
            return
            
        # Initialize selection dictionary
        dateall_selections = {date: False for date in all_dates}
        context.user_data['dateall_selections'] = dateall_selections
        
        # Build message with checkboxes
        msg = ["ğŸ“… á€…á€¬á€›á€„á€ºá€¸á€›á€¾á€­á€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"]
        buttons = []
        
        for date in all_dates:
            pnum = pnumber_per_date.get(date, None)
            pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
            
            is_selected = dateall_selections[date]
            button_text = f"{date}{pnum_str} {'âœ…' if is_selected else 'â¬œ'}"
            buttons.append([InlineKeyboardButton(button_text, callback_data=f"dateall_toggle:{date}")])
        
        buttons.append([InlineKeyboardButton("ğŸ‘â€ğŸ—¨ View", callback_data="dateall_view")])
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await update.message.reply_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in dateall: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def dateall_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, date_key = query.data.split(':')
        dateall_selections = context.user_data.get('dateall_selections', {})
        
        if date_key not in dateall_selections:
            await query.edit_message_text("âŒ Error: Date not found")
            return
            
        # Toggle selection status
        dateall_selections[date_key] = not dateall_selections[date_key]
        context.user_data['dateall_selections'] = dateall_selections
        
        # Rebuild the message with updated selections
        msg = ["ğŸ“… á€…á€¬á€›á€„á€ºá€¸á€›á€¾á€­á€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"]
        buttons = []
        
        for date in dateall_selections.keys():
            pnum = pnumber_per_date.get(date, None)
            pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
            
            is_selected = dateall_selections[date]
            button_text = f"{date}{pnum_str} {'âœ…' if is_selected else 'â¬œ'}"
            buttons.append([InlineKeyboardButton(button_text, callback_data=f"dateall_toggle:{date}")])
        
        buttons.append([InlineKeyboardButton("ğŸ‘â€ğŸ—¨ View", callback_data="dateall_view")])
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.edit_message_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in dateall_toggle: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")
async def dateall_view(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        # 1. Get selected dates
        dateall_selections = context.user_data.get('dateall_selections', {})
        selected_dates = [date for date, selected in dateall_selections.items() if selected]
        
        if not selected_dates:
            await query.edit_message_text("âš ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯á€™á€¾ á€™á€›á€½á€±á€¸á€á€»á€šá€ºá€‘á€¬á€¸á€•á€«")
            return

        # 2. Initialize data storage
        user_reports = {}  # {username: {'total_bet': 0, 'power_bet': 0, 'com': X, 'za': Y}}
        grand_totals = {
            'total_bet': 0,
            'power_bet': 0,
            'commission': 0,
            'win_amount': 0,
            'net_result': 0
        }

        # 3. Process bets WITHOUT overbuy adjustment
        for username, user_dates in user_data.items():
            if username not in user_reports:
                user_reports[username] = {
                    'total_bet': 0,
                    'power_bet': 0,
                    'com': com_data.get(username, 0),
                    'za': za_data.get(username, 80)
                }
            
            for date_key in selected_dates:
                if date_key in user_dates:
                    # Track total bets
                    date_total = sum(amt for _, amt in user_dates[date_key])
                    user_reports[username]['total_bet'] += date_total
                    
                    # Track power number bets
                    pnum = pnumber_per_date.get(date_key)
                    if pnum is not None:
                        power_amt = sum(amt for num, amt in user_dates[date_key] if num == pnum)
                        user_reports[username]['power_bet'] += power_amt

        # 4. Calculate financials
        messages = ["ğŸ“Š á€›á€½á€±á€¸á€á€»á€šá€ºá€‘á€¬á€¸á€á€±á€¬ á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º (Overbuy á€™á€•á€«)"]
        messages.append(f"ğŸ“… á€›á€€á€ºá€…á€½á€²á€™á€»á€¬á€¸: {', '.join(selected_dates)}\n")
        
        for username, report in user_reports.items():
            # Calculate values
            commission = (report['total_bet'] * report['com']) // 100
            after_com = report['total_bet'] - commission
            win_amount = report['power_bet'] * report['za']
            net_result = after_com - win_amount
            
            # Build user message
            user_msg = [
                f"ğŸ‘¤ {username}",
                f"ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸: {report['total_bet']}",
                f"ğŸ“Š Com ({report['com']}%): {commission}",
                f"ğŸ’° Com á€•á€¼á€®á€¸: {after_com}"
            ]
            
            if report['power_bet'] > 0:
                user_msg.extend([
                    f"ğŸ”´ Power Number: {report['power_bet']}",
                    f"ğŸ¯ Za ({report['za']}): {win_amount}"
                ])
            
            user_msg.append(
                f"ğŸ“ˆ á€›á€œá€’á€º: {abs(net_result)} ({'á€’á€­á€¯á€„á€ºá€€á€•á€±á€¸á€›á€”á€º' if net_result < 0 else 'á€’á€­á€¯á€„á€ºá€€á€›á€™á€Šá€º'})"
            )
            
            messages.append("\n".join(user_msg))
            messages.append("â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯")
            
            # Update grand totals
            grand_totals['total_bet'] += report['total_bet']
            grand_totals['power_bet'] += report['power_bet']
            grand_totals['commission'] += commission
            grand_totals['win_amount'] += win_amount
            grand_totals['net_result'] += net_result

        # 5. Add grand totals
        messages.append("\nğŸ“Œ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º:")
        messages.append(f"ğŸ’µ á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€œá€±á€¬á€„á€ºá€¸á€€á€¼á€±á€¸: {grand_totals['total_bet']}")
        messages.append(f"ğŸ“Š Com á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {grand_totals['commission']}")
        
        if grand_totals['power_bet'] > 0:
            messages.append(f"ğŸ”´ Power Number á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {grand_totals['power_bet']}")
            messages.append(f"ğŸ¯ Win Amount á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸: {grand_totals['win_amount']}")
        
        messages.append(
            f"ğŸ“Š á€…á€¯á€…á€¯á€•á€±á€«á€„á€ºá€¸á€›á€œá€’á€º: {abs(grand_totals['net_result'])} "
            f"({'á€’á€­á€¯á€„á€ºá€¡á€›á€¾á€¯á€¶á€¸' if grand_totals['net_result'] < 0 else 'á€’á€­á€¯á€„á€ºá€¡á€™á€¼á€á€º'})"
        )

        # 6. Send message (split if too long)
        full_message = "\n".join(messages)
        if len(full_message) > 4000:
            half = len(messages) // 2
            await query.edit_message_text("\n".join(messages[:half]))
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text="\n".join(messages[half:])
            )
        else:
            await query.edit_message_text(full_message)

    except Exception as e:
        logger.error(f"Error in dateall_view: {str(e)}")
        await query.edit_message_text("âŒ á€á€½á€€á€ºá€á€»á€€á€ºá€™á€¾á€¯á€¡á€™á€¾á€¬á€¸á€–á€¼á€…á€ºá€”á€±á€•á€«á€á€Šá€º")
        
async def change_working_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
        
        # Show calendar with AM/PM selection
        keyboard = [
            [InlineKeyboardButton("ğŸ—“ á€œá€€á€ºá€›á€¾á€­á€œá€¡á€á€½á€€á€º á€•á€¼á€€á€¹á€á€’á€­á€”á€º", callback_data="cdate_calendar")],
            [InlineKeyboardButton("â° AM á€›á€½á€±á€¸á€›á€”á€º", callback_data="cdate_am")],
            [InlineKeyboardButton("ğŸŒ™ PM á€›á€½á€±á€¸á€›á€”á€º", callback_data="cdate_pm")],
            [InlineKeyboardButton("ğŸ“† á€šá€”á€±á€·á€–á€½á€„á€·á€ºá€›á€”á€º", callback_data="cdate_open")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "ğŸ‘‰ á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«\n"
            "â€¢ á€•á€¼á€€á€¹á€á€’á€­á€”á€ºá€–á€¼á€„á€·á€ºá€›á€½á€±á€¸á€›á€”á€º: ğŸ—“ á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«\n"
            "â€¢ AM á€á€­á€¯á€·á€•á€¼á€±á€¬á€„á€ºá€¸á€›á€”á€º: â° á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«\n"
            "â€¢ PM á€á€­á€¯á€·á€•á€¼á€±á€¬á€„á€ºá€¸á€›á€”á€º: ğŸŒ™ á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«\n"
            "â€¢ á€šá€”á€±á€·á€á€­á€¯á€·á€•á€¼á€”á€ºá€›á€”á€º: ğŸ“† á€á€œá€¯á€á€ºá€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«",
            reply_markup=reply_markup
        )
    except Exception as e:
        logger.error(f"Error in change_working_date: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def show_calendar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        now = datetime.now(MYANMAR_TIMEZONE)
        year, month = now.year, now.month
        
        # Create calendar header
        cal_header = calendar.month_name[month] + " " + str(year)
        days = ["á€á€”á€„á€ºá€¹á€œá€¬", "á€¡á€„á€ºá€¹á€‚á€«", "á€—á€¯á€’á€¹á€“á€Ÿá€°á€¸", "á€€á€¼á€¬á€á€•á€á€±á€¸", "á€á€±á€¬á€€á€¼á€¬", "á€…á€”á€±", "á€á€”á€„á€ºá€¹á€‚á€”á€½á€±"]
        
        # Generate calendar days
        cal = calendar.monthcalendar(year, month)
        keyboard = []
        keyboard.append([InlineKeyboardButton(cal_header, callback_data="ignore")])
        keyboard.append([InlineKeyboardButton(day, callback_data="ignore") for day in days])
        
        for week in cal:
            week_buttons = []
            for day in week:
                if day == 0:
                    week_buttons.append(InlineKeyboardButton(" ", callback_data="ignore"))
                else:
                    date_str = f"{day:02d}/{month:02d}/{year}"
                    week_buttons.append(InlineKeyboardButton(str(day), callback_data=f"cdate_day:{date_str}"))
            keyboard.append(week_buttons)
        
        # Add navigation and back buttons
        keyboard.append([
            InlineKeyboardButton("â¬…ï¸ á€šá€á€„á€º", callback_data="cdate_prev_month"),
            InlineKeyboardButton("â¡ï¸ á€”á€±á€¬á€€á€º", callback_data="cdate_next_month")
        ])
        keyboard.append([InlineKeyboardButton("ğŸ”™ á€”á€±á€¬á€€á€ºá€á€­á€¯á€·", callback_data="cdate_back")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("ğŸ—“ á€”á€±á€·á€›á€€á€ºá€›á€½á€±á€¸á€›á€”á€º á€•á€¼á€€á€¹á€á€’á€­á€”á€º", reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in show_calendar: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def handle_day_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, date_str = query.data.split(':')
        context.user_data['selected_date'] = date_str
        
        # Ask for AM/PM selection
        keyboard = [
            [InlineKeyboardButton("â° AM", callback_data="cdate_set_am")],
            [InlineKeyboardButton("ğŸŒ™ PM", callback_data="cdate_set_pm")],
            [InlineKeyboardButton("ğŸ”™ á€”á€±á€¬á€€á€ºá€á€­á€¯á€·", callback_data="cdate_back")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            f"ğŸ‘‰ {date_str} á€¡á€á€½á€€á€º á€¡á€á€»á€­á€”á€ºá€•á€­á€¯á€„á€ºá€¸á€›á€½á€±á€¸á€•á€«",
            reply_markup=reply_markup
        )
        
    except Exception as e:
        logger.error(f"Error in handle_day_selection: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def set_am_pm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        global current_working_date
        time_segment = "AM" if "am" in query.data else "PM"
        date_str = context.user_data.get('selected_date', '')
        
        if not date_str:
            await query.edit_message_text("âŒ Error: Date not selected")
            return
            
        current_working_date = f"{date_str} {time_segment}"
        await query.edit_message_text(f"âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ {current_working_date} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        
    except Exception as e:
        logger.error(f"Error in set_am_pm: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def set_am(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global current_working_date
    try:
        if current_working_date:
            date_part = current_working_date.split()[0]
            current_working_date = f"{date_part} AM"
            await update.callback_query.edit_message_text(f"âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ {current_working_date} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        else:
            await update.callback_query.edit_message_text("âŒ á€œá€€á€ºá€›á€¾á€­á€”á€±á€·á€›á€€á€º á€á€á€ºá€™á€¾á€á€ºá€‘á€¬á€¸á€á€¼á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
    except Exception as e:
        logger.error(f"Error in set_am: {str(e)}")
        await update.callback_query.edit_message_text("âŒ Error occurred")

async def set_pm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global current_working_date
    try:
        if current_working_date:
            date_part = current_working_date.split()[0]
            current_working_date = f"{date_part} PM"
            await update.callback_query.edit_message_text(f"âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ {current_working_date} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        else:
            await update.callback_query.edit_message_text("âŒ á€œá€€á€ºá€›á€¾á€­á€”á€±á€·á€›á€€á€º á€á€á€ºá€™á€¾á€á€ºá€‘á€¬á€¸á€á€¼á€„á€ºá€¸á€™á€›á€¾á€­á€•á€«")
    except Exception as e:
        logger.error(f"Error in set_pm: {str(e)}")
        await update.callback_query.edit_message_text("âŒ Error occurred")

async def open_current_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        global current_working_date
        current_working_date = get_current_date_key()
        await query.edit_message_text(f"âœ… á€œá€€á€ºá€›á€¾á€­ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€›á€™á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯ {current_working_date} á€¡á€–á€¼á€…á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
    except Exception as e:
        logger.error(f"Error in open_current_date: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def navigate_month(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Placeholder for month navigation
    await update.callback_query.answer()
    await update.callback_query.edit_message_text("â„¹ï¸ á€œá€™á€»á€¬á€¸á€œá€¾á€”á€ºá€€á€¼á€Šá€·á€ºá€á€¼á€„á€ºá€¸á€¡á€¬á€¸ á€”á€±á€¬á€€á€ºá€‘á€•á€ºá€—á€¬á€¸á€›á€¾á€„á€ºá€¸á€á€½á€„á€º á€‘á€Šá€·á€ºá€á€½á€„á€ºá€¸á€•á€«á€™á€Šá€º")

async def back_to_main(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await change_working_date(update, context)

async def delete_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global admin_id
    try:
        if update.effective_user.id != admin_id:
            await update.message.reply_text("âŒ Admin only command")
            return
            
        # Get all available dates
        available_dates = get_available_dates()
        
        if not available_dates:
            await update.message.reply_text("â„¹ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€…á€¬á€›á€„á€ºá€¸á€™á€¾ á€™á€›á€¾á€­á€á€±á€¸á€•á€«")
            return
            
        # Initialize selection dictionary
        datedelete_selections = {date: False for date in available_dates}
        context.user_data['datedelete_selections'] = datedelete_selections
        
        # Build message with checkboxes
        msg = ["ğŸ—‘ á€–á€»á€€á€ºá€œá€­á€¯á€á€±á€¬á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"]
        buttons = []
        
        for date in available_dates:
            pnum = pnumber_per_date.get(date, None)
            pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
            
            is_selected = datedelete_selections[date]
            button_text = f"{date}{pnum_str} {'âœ…' if is_selected else 'â¬œ'}"
            buttons.append([InlineKeyboardButton(button_text, callback_data=f"datedelete_toggle:{date}")])
        
        buttons.append([InlineKeyboardButton("âœ… Delete Selected", callback_data="datedelete_confirm")])
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await update.message.reply_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in delete_date: {str(e)}")
        await update.message.reply_text(f"âŒ Error: {str(e)}")

async def datedelete_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        _, date_key = query.data.split(':')
        datedelete_selections = context.user_data.get('datedelete_selections', {})
        
        if date_key not in datedelete_selections:
            await query.edit_message_text("âŒ Error: Date not found")
            return
            
        # Toggle selection status
        datedelete_selections[date_key] = not datedelete_selections[date_key]
        context.user_data['datedelete_selections'] = datedelete_selections
        
        # Rebuild the message with updated selections
        msg = ["ğŸ—‘ á€–á€»á€€á€ºá€œá€­á€¯á€á€±á€¬á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«:"]
        buttons = []
        
        for date in datedelete_selections.keys():
            pnum = pnumber_per_date.get(date, None)
            pnum_str = f" [P: {pnum:02d}]" if pnum is not None else ""
            
            is_selected = datedelete_selections[date]
            button_text = f"{date}{pnum_str} {'âœ…' if is_selected else 'â¬œ'}"
            buttons.append([InlineKeyboardButton(button_text, callback_data=f"datedelete_toggle:{date}")])
        
        buttons.append([InlineKeyboardButton("âœ… Delete Selected", callback_data="datedelete_confirm")])
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.edit_message_text("\n".join(msg), reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in datedelete_toggle: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")

async def datedelete_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    try:
        datedelete_selections = context.user_data.get('datedelete_selections', {})
        
        # Get selected dates
        selected_dates = [date for date, selected in datedelete_selections.items() if selected]
        
        if not selected_dates:
            await query.edit_message_text("âš ï¸ á€™á€Šá€ºá€á€Šá€·á€ºá€”á€±á€·á€›á€€á€ºá€€á€­á€¯á€™á€¾ á€™á€›á€½á€±á€¸á€á€»á€šá€ºá€‘á€¬á€¸á€•á€«")
            return
            
        # Delete data for selected dates
        for date_key in selected_dates:
            # Remove from user_data
            for user in list(user_data.keys()):
                if date_key in user_data[user]:
                    del user_data[user][date_key]
                # Remove user if no dates left
                if not user_data[user]:
                    del user_data[user]
            
            # Remove from ledger
            if date_key in ledger:
                del ledger[date_key]
            
            # Remove from break_limits
            if date_key in break_limits:
                del break_limits[date_key]
            
            # Remove from pnumber_per_date
            if date_key in pnumber_per_date:
                del pnumber_per_date[date_key]
            
            # Remove from date_control
            if date_key in date_control:
                del date_control[date_key]
            
            # Remove from overbuy_list
            if date_key in overbuy_list:
                del overbuy_list[date_key]
            
            # Remove from overbuy_selections
            if date_key in overbuy_selections:
                del overbuy_selections[date_key]
        
        # Clear current working date if it was deleted
        global current_working_date
        if current_working_date in selected_dates:
            current_working_date = None
        
        await query.edit_message_text(f"âœ… á€¡á€±á€¬á€€á€ºá€•á€«á€”á€±á€·á€›á€€á€ºá€™á€»á€¬á€¸ á€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®:\n{', '.join(selected_dates)}")
        
    except Exception as e:
        logger.error(f"Error in datedelete_confirm: {str(e)}")
        await query.edit_message_text("âŒ Error occurred")


if __name__ == "__main__":
    if not TOKEN:
        raise ValueError("âŒ BOT_TOKEN environment variable is not set")
        
    app = ApplicationBuilder().token(TOKEN).build()

    # Command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("menu", show_menu))
    app.add_handler(CommandHandler("dateopen", dateopen))
    app.add_handler(CommandHandler("dateclose", dateclose))
    app.add_handler(CommandHandler("ledger", ledger_summary))
    app.add_handler(CommandHandler("break", break_command))
    app.add_handler(CommandHandler("overbuy", overbuy))
    app.add_handler(CommandHandler("pnumber", pnumber))
    app.add_handler(CommandHandler("comandza", comandza))
    app.add_handler(CommandHandler("total", total))
    app.add_handler(CommandHandler("tsent", tsent))
    app.add_handler(CommandHandler("alldata", alldata))
    app.add_handler(CommandHandler("reset", reset_data))
    app.add_handler(CommandHandler("posthis", posthis))
    app.add_handler(CommandHandler("dateall", dateall))
    app.add_handler(CommandHandler("Cdate", change_working_date))
    app.add_handler(CommandHandler("Ddate", delete_date))

    # Callback handlers
    app.add_handler(CallbackQueryHandler(comza_input, pattern=r"^comza:"))
    app.add_handler(CallbackQueryHandler(delete_bet, pattern=r"^delete:"))
    app.add_handler(CallbackQueryHandler(confirm_delete, pattern=r"^confirm_delete:"))
    app.add_handler(CallbackQueryHandler(cancel_delete, pattern=r"^cancel_delete:"))
    app.add_handler(CallbackQueryHandler(overbuy_select, pattern=r"^overbuy_select:"))
    app.add_handler(CallbackQueryHandler(overbuy_select_all, pattern=r"^overbuy_select_all$"))
    app.add_handler(CallbackQueryHandler(overbuy_unselect_all, pattern=r"^overbuy_unselect_all$"))
    app.add_handler(CallbackQueryHandler(overbuy_confirm, pattern=r"^overbuy_confirm$"))
    app.add_handler(CallbackQueryHandler(posthis_callback, pattern=r"^posthis:"))
    app.add_handler(CallbackQueryHandler(dateall_toggle, pattern=r"^dateall_toggle:"))
    app.add_handler(CallbackQueryHandler(dateall_view, pattern=r"^dateall_view$"))
    
    # Calendar handlers
    app.add_handler(CallbackQueryHandler(show_calendar, pattern=r"^cdate_calendar$"))
    app.add_handler(CallbackQueryHandler(handle_day_selection, pattern=r"^cdate_day:"))
    app.add_handler(CallbackQueryHandler(set_am, pattern=r"^cdate_am$"))
    app.add_handler(CallbackQueryHandler(set_pm, pattern=r"^cdate_pm$"))
    app.add_handler(CallbackQueryHandler(set_am_pm, pattern=r"^cdate_set_am$|^cdate_set_pm$"))
    app.add_handler(CallbackQueryHandler(open_current_date, pattern=r"^cdate_open$"))
    app.add_handler(CallbackQueryHandler(navigate_month, pattern=r"^cdate_prev_month$|^cdate_next_month$"))
    app.add_handler(CallbackQueryHandler(back_to_main, pattern=r"^cdate_back$"))
    
    app.add_handler(CallbackQueryHandler(datedelete_toggle, pattern=r"^datedelete_toggle:"))
    app.add_handler(CallbackQueryHandler(datedelete_confirm, pattern=r"^datedelete_confirm$"))

    # Message handlers
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.Regex(r'^[\u1000-\u109F\s]+$'), handle_menu_selection))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, comza_text))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    logger.info("ğŸš€ Bot is starting...")
    app.run_polling()
